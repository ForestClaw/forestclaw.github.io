<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ForestClaw: fclaw_convenience.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ForestClaw
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fclaw_convenience.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Routines for domain creation, adaptation, partitioning and searching.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="forestclaw_8h_source.html">forestclaw.h</a>&gt;</code><br />
</div>
<p><a href="fclaw__convenience_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a60c45355e1acd9e4333b8f06b301b471" id="r_a60c45355e1acd9e4333b8f06b301b471"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#a60c45355e1acd9e4333b8f06b301b471">fclaw_integrate_ray_t</a>) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *ray, double *integral, void *user)</td></tr>
<tr class="memdesc:a60c45355e1acd9e4333b8f06b301b471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to compute the integral of a "ray" within a patch.  <br /></td></tr>
<tr class="separator:a60c45355e1acd9e4333b8f06b301b471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17656b16b92d877dbaf9ec5f269643a1" id="r_a17656b16b92d877dbaf9ec5f269643a1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#a17656b16b92d877dbaf9ec5f269643a1">fclaw_interpolate_point_t</a>) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *point, void *user)</td></tr>
<tr class="memdesc:a17656b16b92d877dbaf9ec5f269643a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to compute the interpolation data for a point and a patch.  <br /></td></tr>
<tr class="separator:a17656b16b92d877dbaf9ec5f269643a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8fbbffd7bda172a9be2abade6178e662" id="r_a8fbbffd7bda172a9be2abade6178e662"><td class="memItemLeft" align="right" valign="top"><a id="a8fbbffd7bda172a9be2abade6178e662" name="a8fbbffd7bda172a9be2abade6178e662"></a>
<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_new_unitsquare</b> (sc_MPI_Comm mpicomm, int initial_level)</td></tr>
<tr class="memdesc:a8fbbffd7bda172a9be2abade6178e662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a 2D domain for the unitsquare. <br /></td></tr>
<tr class="separator:a8fbbffd7bda172a9be2abade6178e662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15ac6320549032aee3c779e10a005c9" id="r_ac15ac6320549032aee3c779e10a005c9"><td class="memItemLeft" align="right" valign="top"><a id="ac15ac6320549032aee3c779e10a005c9" name="ac15ac6320549032aee3c779e10a005c9"></a>
<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_new_2d_torus</b> (sc_MPI_Comm mpicomm, int initial_level)</td></tr>
<tr class="memdesc:ac15ac6320549032aee3c779e10a005c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a 2D periodoc domain for a torus consisting of one block. <br /></td></tr>
<tr class="separator:ac15ac6320549032aee3c779e10a005c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046812a3d99332b2e0a33b1ffe348647" id="r_a046812a3d99332b2e0a33b1ffe348647"><td class="memItemLeft" align="right" valign="top"><a id="a046812a3d99332b2e0a33b1ffe348647" name="a046812a3d99332b2e0a33b1ffe348647"></a>
<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_new_2d_twosphere</b> (sc_MPI_Comm mpicomm, int initial_level)</td></tr>
<tr class="memdesc:a046812a3d99332b2e0a33b1ffe348647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a 2D domain for a pillowsphere consisting of two blocks. <br /></td></tr>
<tr class="separator:a046812a3d99332b2e0a33b1ffe348647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef899f92cd6b389ac4c76925ca4a71b3" id="r_aef899f92cd6b389ac4c76925ca4a71b3"><td class="memItemLeft" align="right" valign="top"><a id="aef899f92cd6b389ac4c76925ca4a71b3" name="aef899f92cd6b389ac4c76925ca4a71b3"></a>
<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_new_2d_cubedsphere</b> (sc_MPI_Comm mpicomm, int initial_level)</td></tr>
<tr class="memdesc:aef899f92cd6b389ac4c76925ca4a71b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a 2D domain for a cubed sphere consisting of six blocks. <br /></td></tr>
<tr class="separator:aef899f92cd6b389ac4c76925ca4a71b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2fec81cf61a3788209d65012355d4d" id="r_a2f2fec81cf61a3788209d65012355d4d"><td class="memItemLeft" align="right" valign="top"><a id="a2f2fec81cf61a3788209d65012355d4d" name="a2f2fec81cf61a3788209d65012355d4d"></a>
<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_new_2d_disk</b> (sc_MPI_Comm mpicomm, int periodic_in_x, int periodic_in_y, int initial_level)</td></tr>
<tr class="memdesc:a2f2fec81cf61a3788209d65012355d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a 2D domain for a spherical disk consisting of five blocks. <br /></td></tr>
<tr class="separator:a2f2fec81cf61a3788209d65012355d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d9e262cdb3559ccd6b226797b621bd" id="r_ac2d9e262cdb3559ccd6b226797b621bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#ac2d9e262cdb3559ccd6b226797b621bd">fclaw_domain_new_2d_brick</a> (sc_MPI_Comm mpicomm, int blocks_in_x, int blocks_in_y, int periodic_in_x, int periodic_in_y, int initial_level)</td></tr>
<tr class="memdesc:ac2d9e262cdb3559ccd6b226797b621bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a brick connectivity, that is, a rectangular grid of blocks.  <br /></td></tr>
<tr class="separator:ac2d9e262cdb3559ccd6b226797b621bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b087846fd41246d5eb1e0b56a196282" id="r_a6b087846fd41246d5eb1e0b56a196282"><td class="memItemLeft" align="right" valign="top"><a id="a6b087846fd41246d5eb1e0b56a196282" name="a6b087846fd41246d5eb1e0b56a196282"></a>
<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_new_unitcube</b> (sc_MPI_Comm mpicomm, int initial_level)</td></tr>
<tr class="memdesc:a6b087846fd41246d5eb1e0b56a196282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a 3D domain for the unitcube. <br /></td></tr>
<tr class="separator:a6b087846fd41246d5eb1e0b56a196282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a40a9720633a624f6cc355a1812feb" id="r_ac5a40a9720633a624f6cc355a1812feb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#ac5a40a9720633a624f6cc355a1812feb">fclaw_domain_new_3d_brick</a> (sc_MPI_Comm mpicomm, int blocks_in_x, int blocks_in_y, int blocks_in_z, int periodic_in_x, int periodic_in_y, int periodic_in_z, int initial_level)</td></tr>
<tr class="memdesc:ac5a40a9720633a624f6cc355a1812feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a brick connectivity, that is, a rectangular grid of blocks.  <br /></td></tr>
<tr class="separator:ac5a40a9720633a624f6cc355a1812feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30f060b78ee7a8b4074ee9e5e503376" id="r_ae30f060b78ee7a8b4074ee9e5e503376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#ae30f060b78ee7a8b4074ee9e5e503376">fclaw_domain_destroy</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:ae30f060b78ee7a8b4074ee9e5e503376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a domain structure.  <br /></td></tr>
<tr class="separator:ae30f060b78ee7a8b4074ee9e5e503376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d06433d0f62c4103e631e94abc8cf8" id="r_a02d06433d0f62c4103e631e94abc8cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#a02d06433d0f62c4103e631e94abc8cf8">fclaw_domain_adapt</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a02d06433d0f62c4103e631e94abc8cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new domain based on refine and coarsen marks set previously.  <br /></td></tr>
<tr class="separator:a02d06433d0f62c4103e631e94abc8cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa3b318e719d6a50f9763a0e23c96a5" id="r_a5aa3b318e719d6a50f9763a0e23c96a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#a5aa3b318e719d6a50f9763a0e23c96a5">fclaw_domain_partition</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int weight_exponent)</td></tr>
<tr class="memdesc:a5aa3b318e719d6a50f9763a0e23c96a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a repartitioned domain after fclaw_domain_adapt returned non-NULL.  <br /></td></tr>
<tr class="separator:a5aa3b318e719d6a50f9763a0e23c96a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1342dff14c97ecca11ecef128e020a" id="r_abd1342dff14c97ecca11ecef128e020a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#abd1342dff14c97ecca11ecef128e020a">fclaw_domain_partition_unchanged</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int *unchanged_first, int *unchanged_length, int *unchanged_old_first)</td></tr>
<tr class="memdesc:abd1342dff14c97ecca11ecef128e020a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the window of patches that is not transferred on partition.  <br /></td></tr>
<tr class="separator:abd1342dff14c97ecca11ecef128e020a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13be81bd4ed414aced071cd018fcef70" id="r_a13be81bd4ed414aced071cd018fcef70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#a13be81bd4ed414aced071cd018fcef70">fclaw_domain_complete</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a13be81bd4ed414aced071cd018fcef70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after fclaw_domain_partition returned non-NULL.  <br /></td></tr>
<tr class="separator:a13be81bd4ed414aced071cd018fcef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e5576a372135ea5d6aa8100b8dbd1c" id="r_a62e5576a372135ea5d6aa8100b8dbd1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#a62e5576a372135ea5d6aa8100b8dbd1c">fclaw_domain_write_vtk</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, const char *basename)</td></tr>
<tr class="memdesc:a62e5576a372135ea5d6aa8100b8dbd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write VTK file(s) for a domain structure.  <br /></td></tr>
<tr class="separator:a62e5576a372135ea5d6aa8100b8dbd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57ff972a91934d7e385fa07c1a910b5" id="r_ad57ff972a91934d7e385fa07c1a910b5"><td class="memItemLeft" align="right" valign="top"><a id="ad57ff972a91934d7e385fa07c1a910b5" name="ad57ff972a91934d7e385fa07c1a910b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_list_levels</b> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int log_priority)</td></tr>
<tr class="memdesc:ad57ff972a91934d7e385fa07c1a910b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print patch number by level on all processors. <br /></td></tr>
<tr class="separator:ad57ff972a91934d7e385fa07c1a910b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af5ad1addfb46d12349437798e33b5b" id="r_a2af5ad1addfb46d12349437798e33b5b"><td class="memItemLeft" align="right" valign="top"><a id="a2af5ad1addfb46d12349437798e33b5b" name="a2af5ad1addfb46d12349437798e33b5b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_list_neighbors</b> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int log_priority)</td></tr>
<tr class="memdesc:a2af5ad1addfb46d12349437798e33b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print face neighbor status for each face. <br /></td></tr>
<tr class="separator:a2af5ad1addfb46d12349437798e33b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a73e93a9956c187734a0537b10f880" id="r_a14a73e93a9956c187734a0537b10f880"><td class="memItemLeft" align="right" valign="top"><a id="a14a73e93a9956c187734a0537b10f880" name="a14a73e93a9956c187734a0537b10f880"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_list_adapted</b> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *old_domain, <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *new_domain, int log_priority)</td></tr>
<tr class="memdesc:a14a73e93a9956c187734a0537b10f880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print information on adapted patches. <br /></td></tr>
<tr class="separator:a14a73e93a9956c187734a0537b10f880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab77ce7c85a225b3e6bacaa9a2905ab" id="r_a2ab77ce7c85a225b3e6bacaa9a2905ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#a2ab77ce7c85a225b3e6bacaa9a2905ab">fclaw_domain_search_points</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, sc_array_t *block_offsets, sc_array_t *coordinates, sc_array_t *results)</td></tr>
<tr class="memdesc:a2ab77ce7c85a225b3e6bacaa9a2905ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search tuples of (block number, x, y, (z for 3D) coordinates) in the mesh.  <br /></td></tr>
<tr class="separator:a2ab77ce7c85a225b3e6bacaa9a2905ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93719bcf8859c7285aafa4f8c312f62" id="r_ac93719bcf8859c7285aafa4f8c312f62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#ac93719bcf8859c7285aafa4f8c312f62">fclaw_domain_integrate_rays</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="fclaw__convenience_8h.html#a60c45355e1acd9e4333b8f06b301b471">fclaw_integrate_ray_t</a> intersect, sc_array_t *rays, sc_array_t *integrals, void *user)</td></tr>
<tr class="memdesc:ac93719bcf8859c7285aafa4f8c312f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integrals of an array of user-defined rays.  <br /></td></tr>
<tr class="separator:ac93719bcf8859c7285aafa4f8c312f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291124e3c3913fff30a0c98834086ad8" id="r_a291124e3c3913fff30a0c98834086ad8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fclaw__convenience_8h.html#a291124e3c3913fff30a0c98834086ad8">fclaw_overlap_exchange</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, sc_array_t *query_points, <a class="el" href="fclaw__convenience_8h.html#a17656b16b92d877dbaf9ec5f269643a1">fclaw_interpolate_point_t</a> interpolate, void *user)</td></tr>
<tr class="memdesc:a291124e3c3913fff30a0c98834086ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange interpolation data of query points between two domains.  <br /></td></tr>
<tr class="separator:a291124e3c3913fff30a0c98834086ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Routines for domain creation, adaptation, partitioning and searching. </p>
<p>This file provides functions to create 2D and 3D domains from existing connectivity instances as well as some default domains like the unit cube or a cubed sphere.</p>
<p>This file also provides functions to perform domain refinement, coarsening and repartitioning.</p>
<p>Additionally, there are several functionalities based on searching the domain ranging from searching points to ray integration and the exchange of interpolation data for mesh coupling. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a60c45355e1acd9e4333b8f06b301b471" name="a60c45355e1acd9e4333b8f06b301b471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c45355e1acd9e4333b8f06b301b471">&#9670;&#160;</a></span>fclaw_integrate_ray_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fclaw_integrate_ray_t) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *ray, double *integral, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to compute the integral of a "ray" within a patch. </p>
<p>This function can be passed to <a class="el" href="fclaw__convenience_8h.html#ac93719bcf8859c7285aafa4f8c312f62">fclaw_domain_integrate_rays</a> to eventually compute the integrals over the whole domain for an array of rays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain to integrate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>The patch under consideration. When on a leaf, this is a valid forestclaw patch. Otherwise, this is a temporary artificial patch containing all standard patch information except for the pointer to the next patch and user-data. Only the FCLAW2D_PATCH_CHILDID and the FCLAW2D_PATCH_ON_BLOCK_FACE_* flags are set. Artificial patches are generally ancestors of valid forestclaw patches that are leaves. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>The block id of the patch under consideration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>When on a leaf, this is a valid patch number, as always relative to its block. For a leaf, this callback must set the integral value to the local contribution of this patch and ray. Otherwise, patchno is -1. In this case, the integral value is ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>Representation of a "ray"; user-defined. Points to an array element of the rays passed to <a class="el" href="fclaw__convenience_8h.html#ac93719bcf8859c7285aafa4f8c312f62">fclaw_domain_integrate_rays</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">integral</td><td>The integral value associated with the ray. On input this is 0. For leaves this callback must set it to the exact integral contribution for this patch and ray. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Arbitrary data passed in earlier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is a possible/partial intersection of the patch (which may be an ancestor) with the ray. This may be a false positive; we'll be fine. Return false if there is definitely no intersection. Only for leaves, this function must compute the exact integral contribution for this patch by intersecting this ray and store it in the <em>integral</em> output argument. The integral value may well be 0. if the intersection is, in fact, none (a false positive). </dd></dl>

</div>
</div>
<a id="a17656b16b92d877dbaf9ec5f269643a1" name="a17656b16b92d877dbaf9ec5f269643a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17656b16b92d877dbaf9ec5f269643a1">&#9670;&#160;</a></span>fclaw_interpolate_point_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* fclaw_interpolate_point_t) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *point, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to compute the interpolation data for a point and a patch. </p>
<p>This function can be passed to <a class="el" href="fclaw__convenience_8h.html#a291124e3c3913fff30a0c98834086ad8">fclaw_overlap_exchange</a> to eventually compute the interpolation data over the whole producer domain for an array of points. It will be called both in a partition search and a local search of the producer domain. Use <a class="el" href="forestclaw_8h.html#a41128e9bdff0db4749fd605f2dddaa87">fclaw_domain_is_meta</a>, to determine which is the case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain we interpolate on. On the producer side, this is a valid forestclaw domain. On the consumer side, this is a temporary artifical domain. Only the mpi-information (mpicomm, mpisize and mpirank) as well as the backend data (pp, pp_owned and attributes) are set. The backend data is not owned and shall not be changed by the callback. The mpirank is set to a valid rank only when we are at a leaf (a patch that belongs to exactly one process) of the partition search, else it will be -1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>The patch under consideration. When on a leaf on the producer side, this is a valid patch from the producer domain. Otherwise, this is a temporary artificial patch containing all standard patch information except for the pointer to the next patch and user-data. Only the FCLAW2D_PATCH_CHILDID and the FCLAW2D_PATCH_ON_BLOCK_FACE_* flags are set. Artificial patches are generally ancestors of valid forestclaw patches that are leaves. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>The block id of the patch under consideration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>If patchno is -1, we are on an artifical patch. Otherwise, this is a valid patchno from the producer domain. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">point</td><td>Representation of a point; user-defined. Points to an array element of the query points passed to <a class="el" href="fclaw__convenience_8h.html#a291124e3c3913fff30a0c98834086ad8">fclaw_overlap_exchange</a>. If patchno is non-negative, the points interpolation data should be updated by the local patch's contribution. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Arbitrary data passed in earlier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if there is a possible contribution of the patch or one of its ancestors to the point interpolation data. Return false if there is definitely no contribution. If we are on a leaf on the producer side (patchno is non-negative) or the consumer side (domain_is_meta and mpirank is non-negative) this callback should do an exact test for contribution. Else, the return value may be a false positive, we'll be fine. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a02d06433d0f62c4103e631e94abc8cf8" name="a02d06433d0f62c4103e631e94abc8cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d06433d0f62c4103e631e94abc8cf8">&#9670;&#160;</a></span>fclaw_domain_adapt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> * fclaw_domain_adapt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new domain based on refine and coarsen marks set previously. </p>
<p>All refine and coarsen markers are cancelled when this function is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>Current domain with set adaptation markers. It stays alive because it is needed to project numerical values to the adapted domain. If adapted, no queries are allowed afterwards. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Adapted domain if refinement occurred, or NULL. The return status is identical across all ranks. </dd></dl>

</div>
</div>
<a id="a13be81bd4ed414aced071cd018fcef70" name="a13be81bd4ed414aced071cd018fcef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13be81bd4ed414aced071cd018fcef70">&#9670;&#160;</a></span>fclaw_domain_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after fclaw_domain_partition returned non-NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>Current domain that was partitioned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae30f060b78ee7a8b4074ee9e5e503376" name="ae30f060b78ee7a8b4074ee9e5e503376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30f060b78ee7a8b4074ee9e5e503376">&#9670;&#160;</a></span>fclaw_domain_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a domain structure. </p>
<p>Also destroy all attributes. </p>

</div>
</div>
<a id="ac93719bcf8859c7285aafa4f8c312f62" name="ac93719bcf8859c7285aafa4f8c312f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93719bcf8859c7285aafa4f8c312f62">&#9670;&#160;</a></span>fclaw_domain_integrate_rays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_integrate_rays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fclaw__convenience_8h.html#a60c45355e1acd9e4333b8f06b301b471">fclaw_integrate_ray_t</a>&#160;</td>
          <td class="paramname"><em>intersect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_array_t *&#160;</td>
          <td class="paramname"><em>rays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_array_t *&#160;</td>
          <td class="paramname"><em>integrals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the integrals of an array of user-defined rays. </p>
<p>The integral for each ray and intersection quadrant is supplied by a callback. We store the results in an array of integral values of type double.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain to integrate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intersect</td><td>Callback function that returns true if a ray intersects a patch and &ndash; when called for a leaf &ndash; shall output the integral of the ray segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rays</td><td>Array containing the rays of user-defined type. Each entry contains one item of arbitrary data. We do not dereference, just pass pointers around. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">integrals</td><td>Array of double variables. The number of entries must equal the number of rays. Input values ignored. On output, we provide the final integral values. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Arbitrary data to be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2d9e262cdb3559ccd6b226797b621bd" name="ac2d9e262cdb3559ccd6b226797b621bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d9e262cdb3559ccd6b226797b621bd">&#9670;&#160;</a></span>fclaw_domain_new_2d_brick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> * fclaw_domain_new_2d_brick </td>
          <td>(</td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocks_in_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocks_in_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>periodic_in_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>periodic_in_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initial_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a brick connectivity, that is, a rectangular grid of blocks. </p>
<p>The origin is in the lower-left corner of the brick. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>We expect sc_MPI_Init to be called earlier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocks_in_x</td><td>Positive number of blocks in x direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocks_in_y</td><td>Positive number of blocks in y direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic_in_x</td><td>True if the right side of the rightmost blocks connect periodically to the left side of the leftmost blocks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic_in_y</td><td>Periodicity along the vertical direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_level</td><td>A non-negative integer &lt;= P4EST_QMAXLEVEL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully initialized domain structure. </dd></dl>

</div>
</div>
<a id="ac5a40a9720633a624f6cc355a1812feb" name="ac5a40a9720633a624f6cc355a1812feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a40a9720633a624f6cc355a1812feb">&#9670;&#160;</a></span>fclaw_domain_new_3d_brick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> * fclaw_domain_new_3d_brick </td>
          <td>(</td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocks_in_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocks_in_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocks_in_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>periodic_in_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>periodic_in_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>periodic_in_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initial_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a brick connectivity, that is, a rectangular grid of blocks. </p>
<p>The origin is in the lower-left corner of the brick. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>We expect sc_MPI_Init to be called earlier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocks_in_x</td><td>Positive number of blocks in x direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocks_in_y</td><td>Positive number of blocks in y direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocks_in_z</td><td>Positive number of blocks in z direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic_in_x</td><td>True if the right side of the rightmost blocks connect periodically to the left side of the leftmost blocks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic_in_y</td><td>Periodicity in y direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">periodic_in_z</td><td>Periodicity in z direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_level</td><td>A non-negative integer &lt;= P4EST_QMAXLEVEL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully initialized domain structure. </dd></dl>

</div>
</div>
<a id="a5aa3b318e719d6a50f9763a0e23c96a5" name="a5aa3b318e719d6a50f9763a0e23c96a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa3b318e719d6a50f9763a0e23c96a5">&#9670;&#160;</a></span>fclaw_domain_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> * fclaw_domain_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>weight_exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a repartitioned domain after fclaw_domain_adapt returned non-NULL. </p>
<p>All refine and coarsen markers are cancelled when this function is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>Current domain that was adapted previously. It stays alive because it is needed to transfer numerical values to the new partition. If partitioned, no queries allowed afterwards. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight_exponent</td><td>The patches are weighted with an integer factor 2 ** (level * exponent). If the exponent is 0, all patches have equal weight. If it is 1, smaller patches are considered more expensive by a factor two per level increase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partitioned domain if different, or NULL. The return status is identical across all ranks. </dd></dl>

</div>
</div>
<a id="abd1342dff14c97ecca11ecef128e020a" name="abd1342dff14c97ecca11ecef128e020a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1342dff14c97ecca11ecef128e020a">&#9670;&#160;</a></span>fclaw_domain_partition_unchanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_partition_unchanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>unchanged_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>unchanged_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>unchanged_old_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the window of patches that is not transferred on partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>A domain after a non-trivial partition and before calling <a class="el" href="fclaw__convenience_8h.html#a13be81bd4ed414aced071cd018fcef70">fclaw_domain_complete</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unchanged_first</td><td>First still-local patch in the new partition. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unchanged_length</td><td>Number of patches that not changed owners. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unchanged_old_first</td><td>First stayed_local patch in the old partition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab77ce7c85a225b3e6bacaa9a2905ab" name="a2ab77ce7c85a225b3e6bacaa9a2905ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab77ce7c85a225b3e6bacaa9a2905ab">&#9670;&#160;</a></span>fclaw_domain_search_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_search_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_array_t *&#160;</td>
          <td class="paramname"><em>block_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_array_t *&#160;</td>
          <td class="paramname"><em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_array_t *&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search tuples of (block number, x, y, (z for 3D) coordinates) in the mesh. </p>
<p>The coordinates must be in [0, 1]^2 (or [0, 1]^3 for 3D domains) The input data must be equal on every process: This is a collective call.</p>
<p>A point is found at most once even if it is on a patch boundary. We return the smallest patch number on the smallest processor touching it. However, if a point is on a block boundary, it must be decided before calling this function which tree shall be queried for it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Must be valid domain structure. Will not be changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_offsets</td><td>Monotonous array of (num_blocks + 1) int variables. The points to search in block t in [0, num_blocks) have indices [block_offsets[t], block_offsets[t + 1]) in the <b>coordinates</b> and results arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinates</td><td>An array of elem_size == 2 * sizeof (double) with entries (x, y) in [0, 1]^2, or an array of elem_size == 3 * sizeof (double) with entries (x, y, z) in [0, 1]^3 for 3D domains. Of these entries, there are <b>block_offsets</b>[num_blocks] many. We do not enforce the coordinate ranges and simply do not find any point outside its block. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>On input, an array of type int and an element count of <b>block_offsets</b>[num_blocks]. The data in <b>results</b> is ignored on input. On output, an entry will be -1 if the point has not been found on this process, or the patch number within its block otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62e5576a372135ea5d6aa8100b8dbd1c" name="a62e5576a372135ea5d6aa8100b8dbd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e5576a372135ea5d6aa8100b8dbd1c">&#9670;&#160;</a></span>fclaw_domain_write_vtk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_write_vtk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write VTK file(s) for a domain structure. </p>
<p>Each patch is drawn as one rectangle. We ignore any geometric transformations. and use the vertex locations specified in the p4est's connectivity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>A valid domain structure. Is not changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basename</td><td>Filename prefix passed to p4est_vtk functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a291124e3c3913fff30a0c98834086ad8" name="a291124e3c3913fff30a0c98834086ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291124e3c3913fff30a0c98834086ad8">&#9670;&#160;</a></span>fclaw_overlap_exchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_overlap_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_array_t *&#160;</td>
          <td class="paramname"><em>query_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fclaw__convenience_8h.html#a17656b16b92d877dbaf9ec5f269643a1">fclaw_interpolate_point_t</a>&#160;</td>
          <td class="paramname"><em>interpolate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange interpolation data of query points between two domains. </p>
<p>We compute the user-defined interpolation data of an array of user-defined query points, which originate from the so-called consumer side. The interpolation data will be computed on the domain of the so-called producer-side based on a <a class="el" href="fclaw__convenience_8h.html#a17656b16b92d877dbaf9ec5f269643a1">fclaw_interpolate_point_t</a> callback function. Afterwards, the results will be collected and combined on the consumer side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The producer domain to interpolate on. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">query_points</td><td>Array containing points of user-defined type. Each entry contains one item of arbitrary data. We do not dereference, just pass pointers around. The points will be sent via MPI, so they may not contain pointers to further data. The array is defined processor-local and may contain different points on different processes. The query points are supposed to be computed (and transformed to the producer space by an inverse mapping) locally on the consumer side. On output, the points will contain collected interpolation data according to <b>interpolate</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolate</td><td>Callback function that returns true if a point intersects a patch and &ndash; when called for a leaf on the producer side &ndash; shall write the interpolation data for the current point-patch-combination into the user-defined point structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Arbitrary data to be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
