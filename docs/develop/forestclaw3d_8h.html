<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ForestClaw: forestclaw3d.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ForestClaw
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">forestclaw3d.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="fclaw__base_8h_source.html">fclaw_base.h</a>&gt;</code><br />
<code>#include &lt;sc_keyvalue.h&gt;</code><br />
</div>
<p><a href="forestclaw3d_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfclaw3d__patch.html">fclaw3d_patch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The metadata structure for a forest leaf, which is a forestclaw patch.  <a href="structfclaw3d__patch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfclaw3d__block.html">fclaw3d_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data Structure for a block.  <a href="structfclaw3d__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfclaw3d__domain__persist.html">fclaw3d_domain_persist</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure identify parameters that are copied from a domain to a new domain derived by adaptation or partitioning.  <a href="structfclaw3d__domain__persist.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfclaw3d__domain.html">fclaw3d_domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The domain structure is a collection of blocks.  <a href="structfclaw3d__domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfclaw3d__domain__exchange.html">fclaw3d_domain_exchange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for storing allocated data for parallel exchange.  <a href="structfclaw3d__domain__exchange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Data Types</h2></td></tr>
<tr class="memitem:a53c832f258cd7cd2ceb5f3a088700021"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021">fclaw3d_patch_flags_t</a> { <br />
&#160;&#160;<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021ad932443c340617e3917b60694240cad0">FCLAW3D_PATCH_CHILDID</a> = 0x7, 
<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021aa8f1c1dca91c75f0e217007b9b1cf14f">FCLAW3D_PATCH_FIRST_SIBLING</a> = 0x8, 
<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021ae2b76edb00ff1fdcd19794278f38ea62">FCLAW3D_PATCH_ON_PARALLEL_BOUNDARY</a> = 0x10, 
<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021a5f7c4ebabe3670c770b709fdce36d1af">FCLAW3D_PATCH_IS_GHOST</a> = 0x20, 
<br />
&#160;&#160;<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021ac8dd2dca6249334382c2e76a2761cca5">FCLAW3D_PATCH_ON_BLOCK_FACE_0</a> = 0x040, 
<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021a1f51826c6a98f91ede300dd08b1f55a8">FCLAW3D_PATCH_ON_BLOCK_FACE_1</a> = 0x080, 
<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021a3a47fba116bb81627cbd6fa03bc8d25c">FCLAW3D_PATCH_ON_BLOCK_FACE_2</a> = 0x100, 
<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021a8b0196ef611879f5905c42f245a7edfe">FCLAW3D_PATCH_ON_BLOCK_FACE_3</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021a29f6dd2640a2314f7de4cf07014b0aa7">FCLAW3D_PATCH_ON_BLOCK_FACE_4</a> = 0x400, 
<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021a25dd39dd7f1d5e56c35b681246e01289">FCLAW3D_PATCH_ON_BLOCK_FACE_5</a> = 0x800, 
<a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021aebcd1628615a82cc3de0998e2da97d12">FCLAW3D_PATCH_ON_BLOCK_BOUNDARY</a> = 0xFC0
<br />
 }</td></tr>
<tr class="memdesc:a53c832f258cd7cd2ceb5f3a088700021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for encoding patch information.  <a href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021">More...</a><br /></td></tr>
<tr class="separator:a53c832f258cd7cd2ceb5f3a088700021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be2b4fb91b07a1a8e7c475dc0ab232d"><td class="memItemLeft" align="right" valign="top"><a id="a8be2b4fb91b07a1a8e7c475dc0ab232d"></a>
typedef struct <a class="el" href="structfclaw3d__domain.html">fclaw3d_domain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a></td></tr>
<tr class="memdesc:a8be2b4fb91b07a1a8e7c475dc0ab232d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="structfclaw3d__domain.html" title="The domain structure is a collection of blocks.">fclaw3d_domain</a>. <br /></td></tr>
<tr class="separator:a8be2b4fb91b07a1a8e7c475dc0ab232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16361d7d4684c39fdfeaf4bab73223a"><td class="memItemLeft" align="right" valign="top"><a id="ab16361d7d4684c39fdfeaf4bab73223a"></a>
typedef struct <a class="el" href="structfclaw3d__block.html">fclaw3d_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ab16361d7d4684c39fdfeaf4bab73223a">fclaw3d_block_t</a></td></tr>
<tr class="memdesc:ab16361d7d4684c39fdfeaf4bab73223a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="structfclaw3d__block.html" title="Data Structure for a block.">fclaw3d_block</a>. <br /></td></tr>
<tr class="separator:ab16361d7d4684c39fdfeaf4bab73223a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bdb11fada7424f3958509ad1ded30e"><td class="memItemLeft" align="right" valign="top"><a id="a54bdb11fada7424f3958509ad1ded30e"></a>
typedef struct <a class="el" href="structfclaw3d__patch.html">fclaw3d_patch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a></td></tr>
<tr class="memdesc:a54bdb11fada7424f3958509ad1ded30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="structfclaw3d__patch.html" title="The metadata structure for a forest leaf, which is a forestclaw patch.">fclaw3d_patch</a>. <br /></td></tr>
<tr class="separator:a54bdb11fada7424f3958509ad1ded30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c24c586031971a9d1009852227669c9"><td class="memItemLeft" align="right" valign="top"><a id="a0c24c586031971a9d1009852227669c9"></a>
typedef struct <a class="el" href="structfclaw3d__domain__persist.html">fclaw3d_domain_persist</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a0c24c586031971a9d1009852227669c9">fclaw3d_domain_persist_t</a></td></tr>
<tr class="memdesc:a0c24c586031971a9d1009852227669c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure identify parameters that are copied from a domain to a new domain derived by adaptation or partitioning. <br /></td></tr>
<tr class="separator:a0c24c586031971a9d1009852227669c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94068d8eb1c3f6046e8ad80271d4fed"><td class="memItemLeft" align="right" valign="top"><a id="aa94068d8eb1c3f6046e8ad80271d4fed"></a>
const <a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021">fclaw3d_patch_flags_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#aa94068d8eb1c3f6046e8ad80271d4fed">fclaw3d_patch_block_face_flags</a> [6]</td></tr>
<tr class="memdesc:aa94068d8eb1c3f6046e8ad80271d4fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each of the six faces, the corresponding block boundary flag. <br /></td></tr>
<tr class="separator:aa94068d8eb1c3f6046e8ad80271d4fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Domain Attributes</h2></td></tr>
<tr class="memitem:a0b105bb68f4cd87f571b4d965b966d48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a0b105bb68f4cd87f571b4d965b966d48">fclaw3d_domain_attribute_add</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, const char *name, void *attribute)</td></tr>
<tr class="memdesc:a0b105bb68f4cd87f571b4d965b966d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a named attribute to the domain.  <a href="forestclaw3d_8h.html#a0b105bb68f4cd87f571b4d965b966d48">More...</a><br /></td></tr>
<tr class="separator:a0b105bb68f4cd87f571b4d965b966d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885a030ef869a7399e1a922c3f7eaa31"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a885a030ef869a7399e1a922c3f7eaa31">fclaw3d_domain_attribute_access</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, const char *name, void *default_attr)</td></tr>
<tr class="memdesc:a885a030ef869a7399e1a922c3f7eaa31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a named attribute of the domain.  <a href="forestclaw3d_8h.html#a885a030ef869a7399e1a922c3f7eaa31">More...</a><br /></td></tr>
<tr class="separator:a885a030ef869a7399e1a922c3f7eaa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbb62f54aa61f0c298868469734ec42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#aebbb62f54aa61f0c298868469734ec42">fclaw3d_domain_attribute_remove</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, const char *name)</td></tr>
<tr class="memdesc:aebbb62f54aa61f0c298868469734ec42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a named attribute from the domain.  <a href="forestclaw3d_8h.html#aebbb62f54aa61f0c298868469734ec42">More...</a><br /></td></tr>
<tr class="separator:aebbb62f54aa61f0c298868469734ec42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Topological Properties</h2></td></tr>
<tr class="memitem:a5d935ce12437c884c57bd1d4fc95f2ed"><td class="memItemLeft" align="right" valign="top"><a id="a5d935ce12437c884c57bd1d4fc95f2ed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a5d935ce12437c884c57bd1d4fc95f2ed">fclaw3d_domain_dimension</a> (const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a5d935ce12437c884c57bd1d4fc95f2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the space dimension. <br /></td></tr>
<tr class="separator:a5d935ce12437c884c57bd1d4fc95f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12f618d0be4c1d4673814013a2afadf"><td class="memItemLeft" align="right" valign="top"><a id="af12f618d0be4c1d4673814013a2afadf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#af12f618d0be4c1d4673814013a2afadf">fclaw3d_domain_num_faces</a> (const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:af12f618d0be4c1d4673814013a2afadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of faces of a cube: 4 in 2D, 6 in 3D. <br /></td></tr>
<tr class="separator:af12f618d0be4c1d4673814013a2afadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59964264ebe7709dd6383512c45a4ff"><td class="memItemLeft" align="right" valign="top"><a id="af59964264ebe7709dd6383512c45a4ff"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#af59964264ebe7709dd6383512c45a4ff">fclaw3d_domain_num_edges</a> (const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:af59964264ebe7709dd6383512c45a4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of edges of a cube: 12 in 3D. <br /></td></tr>
<tr class="separator:af59964264ebe7709dd6383512c45a4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd84e237e9c375468a882345ff03ad6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#acd84e237e9c375468a882345ff03ad6a">fclaw3d_domain_num_corners</a> (const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:acd84e237e9c375468a882345ff03ad6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of corners of a cube: 4 in 2D, 8 in 3D.  <a href="forestclaw3d_8h.html#acd84e237e9c375468a882345ff03ad6a">More...</a><br /></td></tr>
<tr class="separator:acd84e237e9c375468a882345ff03ad6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5e8c39a9e63067c590299dba173da6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a0a5e8c39a9e63067c590299dba173da6">fclaw3d_domain_num_face_corners</a> (const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a0a5e8c39a9e63067c590299dba173da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of corners of a cube face: 2 in 2D, 4 in 3D.  <a href="forestclaw3d_8h.html#a0a5e8c39a9e63067c590299dba173da6">More...</a><br /></td></tr>
<tr class="separator:a0a5e8c39a9e63067c590299dba173da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16b9ea129ca8d92d0a281aaad24db4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#af16b9ea129ca8d92d0a281aaad24db4f">fclaw3d_domain_num_orientations</a> (const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:af16b9ea129ca8d92d0a281aaad24db4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of possible orientations of a cube face.  <a href="forestclaw3d_8h.html#af16b9ea129ca8d92d0a281aaad24db4f">More...</a><br /></td></tr>
<tr class="separator:af16b9ea129ca8d92d0a281aaad24db4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ee55d2231b25e0c5ccb38bcf89c9ef"><td class="memItemLeft" align="right" valign="top"><a id="af2ee55d2231b25e0c5ccb38bcf89c9ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#af2ee55d2231b25e0c5ccb38bcf89c9ef">fclaw3d_domain_corner_faces</a> (const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int icorner, int faces[3])</td></tr>
<tr class="memdesc:af2ee55d2231b25e0c5ccb38bcf89c9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the numbers of faces adjacent to a cube corner: 2 in 2D, 3 in 3D. <br /></td></tr>
<tr class="separator:af2ee55d2231b25e0c5ccb38bcf89c9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Patch Functions</h2></td></tr>
<tr class="memitem:a550a23d8122c76b64a7f7e3820723385"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a550a23d8122c76b64a7f7e3820723385">fclaw3d_patch_corner_dimension</a> (const <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *patch, int cornerno)</td></tr>
<tr class="memdesc:a550a23d8122c76b64a7f7e3820723385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of a corner.  <a href="forestclaw3d_8h.html#a550a23d8122c76b64a7f7e3820723385">More...</a><br /></td></tr>
<tr class="separator:a550a23d8122c76b64a7f7e3820723385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47abd0a72ee1585ee63cf3be63661013"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a47abd0a72ee1585ee63cf3be63661013">fclaw3d_patch_childid</a> (const <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *patch)</td></tr>
<tr class="memdesc:a47abd0a72ee1585ee63cf3be63661013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of a patch with respect to its parent in the tree.  <a href="forestclaw3d_8h.html#a47abd0a72ee1585ee63cf3be63661013">More...</a><br /></td></tr>
<tr class="separator:a47abd0a72ee1585ee63cf3be63661013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc11d9d86fa7f7c1f6092c86f850276"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a9cc11d9d86fa7f7c1f6092c86f850276">fclaw3d_patch_is_first_sibling</a> (const <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *patch)</td></tr>
<tr class="memdesc:a9cc11d9d86fa7f7c1f6092c86f850276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a patch is the first in a family of eight siblings.  <a href="forestclaw3d_8h.html#a9cc11d9d86fa7f7c1f6092c86f850276">More...</a><br /></td></tr>
<tr class="separator:a9cc11d9d86fa7f7c1f6092c86f850276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cc315361e4d7b86c5f14001d0a5998"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a02cc315361e4d7b86c5f14001d0a5998">fclaw3d_patch_is_ghost</a> (const <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *patch)</td></tr>
<tr class="memdesc:a02cc315361e4d7b86c5f14001d0a5998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a patch is a parallel ghost patch.  <a href="forestclaw3d_8h.html#a02cc315361e4d7b86c5f14001d0a5998">More...</a><br /></td></tr>
<tr class="separator:a02cc315361e4d7b86c5f14001d0a5998"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Patch Iterators</h2></td></tr>
<tr class="memitem:ac5178a0f55aaa5e3ad02dc2913c94c47"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ac5178a0f55aaa5e3ad02dc2913c94c47">fclaw3d_patch_callback_t</a>) (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *patch, int blockno, int patchno, void *user)</td></tr>
<tr class="memdesc:ac5178a0f55aaa5e3ad02dc2913c94c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback prototype for the patch iterators.  <a href="forestclaw3d_8h.html#ac5178a0f55aaa5e3ad02dc2913c94c47">More...</a><br /></td></tr>
<tr class="separator:ac5178a0f55aaa5e3ad02dc2913c94c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b442159e00a854483ab606f4e0f271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a10b442159e00a854483ab606f4e0f271">fclaw3d_domain_iterate_level</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int level, <a class="el" href="forestclaw3d_8h.html#ac5178a0f55aaa5e3ad02dc2913c94c47">fclaw3d_patch_callback_t</a> pcb, void *user)</td></tr>
<tr class="memdesc:a10b442159e00a854483ab606f4e0f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all local patches on a given level.  <a href="forestclaw3d_8h.html#a10b442159e00a854483ab606f4e0f271">More...</a><br /></td></tr>
<tr class="separator:a10b442159e00a854483ab606f4e0f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44625472baca44e82f30d7709a3b113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ab44625472baca44e82f30d7709a3b113">fclaw3d_domain_iterate_patches</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#ac5178a0f55aaa5e3ad02dc2913c94c47">fclaw3d_patch_callback_t</a> pcb, void *user)</td></tr>
<tr class="memdesc:ab44625472baca44e82f30d7709a3b113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all local patches of all levels.  <a href="forestclaw3d_8h.html#ab44625472baca44e82f30d7709a3b113">More...</a><br /></td></tr>
<tr class="separator:ab44625472baca44e82f30d7709a3b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61f45710072a667e3a7a42af55fe621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#af61f45710072a667e3a7a42af55fe621">fclaw3d_domain_iterate_families</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#ac5178a0f55aaa5e3ad02dc2913c94c47">fclaw3d_patch_callback_t</a> pcb, void *user)</td></tr>
<tr class="memdesc:af61f45710072a667e3a7a42af55fe621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all families of local sibling patches.  <a href="forestclaw3d_8h.html#af61f45710072a667e3a7a42af55fe621">More...</a><br /></td></tr>
<tr class="separator:af61f45710072a667e3a7a42af55fe621"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Patch Neighbors</h2></td></tr>
<tr class="memitem:ae60c1ef0c79a8f9373dd914c1acdd5d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ae60c1ef0c79a8f9373dd914c1acdd5d3">fclaw3d_face_neighbor</a> { <a class="el" href="forestclaw3d_8h.html#ae60c1ef0c79a8f9373dd914c1acdd5d3a7f47f7f3afedb3dae78cf255101b3a4a">FCLAW3D_PATCH_BOUNDARY</a>, 
<a class="el" href="forestclaw3d_8h.html#ae60c1ef0c79a8f9373dd914c1acdd5d3aa8554a9fb0474061513aea8495c39243">FCLAW3D_PATCH_HALFSIZE</a>, 
<a class="el" href="forestclaw3d_8h.html#ae60c1ef0c79a8f9373dd914c1acdd5d3a249f2cda59583db9150ce755990a47c6">FCLAW3D_PATCH_SAMESIZE</a>, 
<a class="el" href="forestclaw3d_8h.html#ae60c1ef0c79a8f9373dd914c1acdd5d3aa8e08f79558d4bab161d1ac012090c85">FCLAW3D_PATCH_DOUBLESIZE</a>
 }</td></tr>
<tr class="memdesc:ae60c1ef0c79a8f9373dd914c1acdd5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of face neighbor.  <a href="forestclaw3d_8h.html#ae60c1ef0c79a8f9373dd914c1acdd5d3">More...</a><br /></td></tr>
<tr class="separator:ae60c1ef0c79a8f9373dd914c1acdd5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e71ccdedcccb2178a72b97359628162"><td class="memItemLeft" align="right" valign="top"><a id="a7e71ccdedcccb2178a72b97359628162"></a>
typedef enum <a class="el" href="forestclaw3d_8h.html#ae60c1ef0c79a8f9373dd914c1acdd5d3">fclaw3d_face_neighbor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a></td></tr>
<tr class="memdesc:a7e71ccdedcccb2178a72b97359628162"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of face neighbor. <br /></td></tr>
<tr class="separator:a7e71ccdedcccb2178a72b97359628162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6406ad1faf09b320a7b20b483d7a1b29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a6406ad1faf09b320a7b20b483d7a1b29">fclaw3d_patch_boundary_type</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int blockno, int patchno, int boundaries[6])</td></tr>
<tr class="memdesc:a6406ad1faf09b320a7b20b483d7a1b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine physical boundary status as 1, or 0 for neighbor patches.  <a href="forestclaw3d_8h.html#a6406ad1faf09b320a7b20b483d7a1b29">More...</a><br /></td></tr>
<tr class="separator:a6406ad1faf09b320a7b20b483d7a1b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbe20eaf00e86e4bccf418328154c53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a0fbe20eaf00e86e4bccf418328154c53">fclaw3d_patch_normal_match</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int blockno, int patchno, int faceno)</td></tr>
<tr class="memdesc:a0fbe20eaf00e86e4bccf418328154c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the normal to a face neighbor align.  <a href="forestclaw3d_8h.html#a0fbe20eaf00e86e4bccf418328154c53">More...</a><br /></td></tr>
<tr class="separator:a0fbe20eaf00e86e4bccf418328154c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0627be8e5090b99c487354e4ae2e7eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ad0627be8e5090b99c487354e4ae2e7eb">fclaw3d_patch_face_neighbors</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int blockno, int patchno, int faceno, int rproc[4], int *rblockno, int rpatchno[4], int *rfaceno)</td></tr>
<tr class="memdesc:ad0627be8e5090b99c487354e4ae2e7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine neighbor patch(es) and orientation across a given face.  <a href="forestclaw3d_8h.html#ad0627be8e5090b99c487354e4ae2e7eb">More...</a><br /></td></tr>
<tr class="separator:ad0627be8e5090b99c487354e4ae2e7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a76479f18d385727b330b29624d77e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a55a76479f18d385727b330b29624d77e">fclaw3d_patch_face_swap</a> (int *faceno, int *rfaceno)</td></tr>
<tr class="memdesc:a55a76479f18d385727b330b29624d77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change perspective across a face neighbor situation.  <a href="forestclaw3d_8h.html#a55a76479f18d385727b330b29624d77e">More...</a><br /></td></tr>
<tr class="separator:a55a76479f18d385727b330b29624d77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f5c76b16c4970b9f567744604886ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a71f5c76b16c4970b9f567744604886ed">fclaw3d_patch_face_transformation</a> (int faceno, int rfaceno, int ftransform[])</td></tr>
<tr class="memdesc:a71f5c76b16c4970b9f567744604886ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an array with the axis combination of a face neighbor transform.  <a href="forestclaw3d_8h.html#a71f5c76b16c4970b9f567744604886ed">More...</a><br /></td></tr>
<tr class="separator:a71f5c76b16c4970b9f567744604886ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33fc03051ea0ae4bf411a3645a0843d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ae33fc03051ea0ae4bf411a3645a0843d">fclaw3d_patch_face_transformation_block</a> (int ftransform[], int sameblock)</td></tr>
<tr class="memdesc:ae33fc03051ea0ae4bf411a3645a0843d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an existing face transformation depending on intra-block usage.  <a href="forestclaw3d_8h.html#ae33fc03051ea0ae4bf411a3645a0843d">More...</a><br /></td></tr>
<tr class="separator:ae33fc03051ea0ae4bf411a3645a0843d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64b13e6b92223d2c42b02e0fc0a0584"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ab64b13e6b92223d2c42b02e0fc0a0584">fclaw3d_patch_face_transformation_intra</a> (int ftransform[])</td></tr>
<tr class="memdesc:ab64b13e6b92223d2c42b02e0fc0a0584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an array with the axis combination of a face neighbor transformation that operates on two patches in the same block (the trivial case).  <a href="forestclaw3d_8h.html#ab64b13e6b92223d2c42b02e0fc0a0584">More...</a><br /></td></tr>
<tr class="separator:ab64b13e6b92223d2c42b02e0fc0a0584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e6551eca85a6da62460fc056e75a50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ac2e6551eca85a6da62460fc056e75a50">fclaw3d_patch_face_transformation_valid</a> (const int ftransform[])</td></tr>
<tr class="memdesc:ac2e6551eca85a6da62460fc056e75a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a face transformation is valid.  <a href="forestclaw3d_8h.html#ac2e6551eca85a6da62460fc056e75a50">More...</a><br /></td></tr>
<tr class="separator:ac2e6551eca85a6da62460fc056e75a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae334a995348fd25c0d1f720484a354dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ae334a995348fd25c0d1f720484a354dd">fclaw3d_patch_transform_face</a> (<a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *ipatch, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *opatch, const int ftransform[], int mx, int my, int mz, int based, int *i, int *j, int *k)</td></tr>
<tr class="memdesc:ae334a995348fd25c0d1f720484a354dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a patch coordinate into a neighbor patch's coordinate system.  <a href="forestclaw3d_8h.html#ae334a995348fd25c0d1f720484a354dd">More...</a><br /></td></tr>
<tr class="separator:ae334a995348fd25c0d1f720484a354dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca37a35d7bb36f0162d089a8c2caa86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a5ca37a35d7bb36f0162d089a8c2caa86">fclaw3d_patch_transform_face2</a> (<a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *ipatch, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *opatch, const int ftransform[], int mx, int my, int mz, int based, int i[], int j[], int k[])</td></tr>
<tr class="memdesc:a5ca37a35d7bb36f0162d089a8c2caa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a patch coordinate into a neighbor patch's coordinate system.  <a href="forestclaw3d_8h.html#a5ca37a35d7bb36f0162d089a8c2caa86">More...</a><br /></td></tr>
<tr class="separator:a5ca37a35d7bb36f0162d089a8c2caa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaba47caa94f508f4c166020500111c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#acaba47caa94f508f4c166020500111c2">fclaw3d_patch_edge_neighbors</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int blockno, int patchno, int edgeno, int rproc[2], int *rblockno, int rpatchno[2], int *redge, <a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a> *neighbor_size)</td></tr>
<tr class="memdesc:acaba47caa94f508f4c166020500111c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine neighbor patch(es) and orientation across a given edge.  <a href="forestclaw3d_8h.html#acaba47caa94f508f4c166020500111c2">More...</a><br /></td></tr>
<tr class="separator:acaba47caa94f508f4c166020500111c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514f04206cc463fdcd5f0a2b98861271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a514f04206cc463fdcd5f0a2b98861271">fclaw3d_patch_edge_swap</a> (int *edgeno, int *redgeno)</td></tr>
<tr class="memdesc:a514f04206cc463fdcd5f0a2b98861271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change perspective across an edge neighbor situation.  <a href="forestclaw3d_8h.html#a514f04206cc463fdcd5f0a2b98861271">More...</a><br /></td></tr>
<tr class="separator:a514f04206cc463fdcd5f0a2b98861271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb28a72d6304be2a11400b727c54f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#addb28a72d6304be2a11400b727c54f81">fclaw3d_patch_transform_edge</a> (<a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *ipatch, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *opatch, int iedge, int is_block_boundary, int mx, int my, int mz, int based, int *i, int *j, int *k)</td></tr>
<tr class="memdesc:addb28a72d6304be2a11400b727c54f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a patch coordinate into a neighbor patch's coordinate system.  <a href="forestclaw3d_8h.html#addb28a72d6304be2a11400b727c54f81">More...</a><br /></td></tr>
<tr class="separator:addb28a72d6304be2a11400b727c54f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064bfc974c8fd4fcb60565d2c2e015cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a064bfc974c8fd4fcb60565d2c2e015cc">fclaw3d_patch_transform_edge2</a> (<a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *ipatch, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *opatch, int iedge, int is_block_boundary, int mx, int my, int mz, int based, int i[], int j[], int k[])</td></tr>
<tr class="memdesc:a064bfc974c8fd4fcb60565d2c2e015cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a patch coordinate into a neighbor patch's coordinate system.  <a href="forestclaw3d_8h.html#a064bfc974c8fd4fcb60565d2c2e015cc">More...</a><br /></td></tr>
<tr class="separator:a064bfc974c8fd4fcb60565d2c2e015cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5c6a52789aa179658ad03ee7f72c8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a8b5c6a52789aa179658ad03ee7f72c8d">fclaw3d_patch_corner_neighbors</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int blockno, int patchno, int cornerno, int *rproc, int *rblockno, int *rpatchno, int *rcorner, <a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a> *neighbor_size)</td></tr>
<tr class="memdesc:a8b5c6a52789aa179658ad03ee7f72c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine neighbor patch(es) and orientation across a given corner.  <a href="forestclaw3d_8h.html#a8b5c6a52789aa179658ad03ee7f72c8d">More...</a><br /></td></tr>
<tr class="separator:a8b5c6a52789aa179658ad03ee7f72c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35f149387e74b3ffa0fab5a9e7f5125"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ab35f149387e74b3ffa0fab5a9e7f5125">fclaw3d_patch_corner_swap</a> (int *cornerno, int *rcornerno)</td></tr>
<tr class="memdesc:ab35f149387e74b3ffa0fab5a9e7f5125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change perspective across a corner neighbor situation.  <a href="forestclaw3d_8h.html#ab35f149387e74b3ffa0fab5a9e7f5125">More...</a><br /></td></tr>
<tr class="separator:ab35f149387e74b3ffa0fab5a9e7f5125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0141755750dd93a9d523f213bf2caac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a0141755750dd93a9d523f213bf2caac8">fclaw3d_patch_transform_corner</a> (<a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *ipatch, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *opatch, int icorner, int is_block_boundary, int mx, int my, int mz, int based, int *i, int *j, int *k)</td></tr>
<tr class="memdesc:a0141755750dd93a9d523f213bf2caac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a patch coordinate into a neighbor patch's coordinate system.  <a href="forestclaw3d_8h.html#a0141755750dd93a9d523f213bf2caac8">More...</a><br /></td></tr>
<tr class="separator:a0141755750dd93a9d523f213bf2caac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a27127614b26721527b3271dc72603c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a8a27127614b26721527b3271dc72603c">fclaw3d_patch_transform_corner2</a> (<a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *ipatch, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *opatch, int icorner, int is_block_boundary, int mx, int my, int mz, int based, int i[], int j[], int k[])</td></tr>
<tr class="memdesc:a8a27127614b26721527b3271dc72603c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a patch coordinate into a neighbor patch's coordinate system.  <a href="forestclaw3d_8h.html#a8a27127614b26721527b3271dc72603c">More...</a><br /></td></tr>
<tr class="separator:a8a27127614b26721527b3271dc72603c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Adaptivity</h2></td></tr>
<tr class="memitem:a7e7e5dcadc6cc6b2f6bbff4d9894fb89"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a7e7e5dcadc6cc6b2f6bbff4d9894fb89">fclaw3d_match_callback_t</a>) (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *old_domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *old_patch, <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *new_domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *new_patch, <a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a> newsize, int blockno, int old_patchno, int new_patchno, void *user)</td></tr>
<tr class="memdesc:a7e7e5dcadc6cc6b2f6bbff4d9894fb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback prototype used in fclaw3d_domain_iterate_adapted.  <a href="forestclaw3d_8h.html#a7e7e5dcadc6cc6b2f6bbff4d9894fb89">More...</a><br /></td></tr>
<tr class="separator:a7e7e5dcadc6cc6b2f6bbff4d9894fb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5de9b9ca73b4ac6ac9ac61c1f8b7c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#abb5de9b9ca73b4ac6ac9ac61c1f8b7c0">fclaw3d_domain_set_refinement</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int smooth_refine, int smooth_level, int coarsen_delay)</td></tr>
<tr class="memdesc:abb5de9b9ca73b4ac6ac9ac61c1f8b7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameters of refinement strategy in a domain.  <a href="forestclaw3d_8h.html#abb5de9b9ca73b4ac6ac9ac61c1f8b7c0">More...</a><br /></td></tr>
<tr class="separator:abb5de9b9ca73b4ac6ac9ac61c1f8b7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a415c190da8fac6947eef99ea36a0bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a7a415c190da8fac6947eef99ea36a0bf">fclaw3d_patch_mark_refine</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int blockno, int patchno)</td></tr>
<tr class="memdesc:a7a415c190da8fac6947eef99ea36a0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a patch for refinement.  <a href="forestclaw3d_8h.html#a7a415c190da8fac6947eef99ea36a0bf">More...</a><br /></td></tr>
<tr class="separator:a7a415c190da8fac6947eef99ea36a0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef32d6d97f599b273489277011344dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#afef32d6d97f599b273489277011344dc">fclaw3d_patch_mark_coarsen</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int blockno, int patchno)</td></tr>
<tr class="memdesc:afef32d6d97f599b273489277011344dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a patch for coarsening.  <a href="forestclaw3d_8h.html#afef32d6d97f599b273489277011344dc">More...</a><br /></td></tr>
<tr class="separator:afef32d6d97f599b273489277011344dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7c71d9ac7b47562f078c9a8434ff9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#acc7c71d9ac7b47562f078c9a8434ff9d">fclaw3d_domain_iterate_adapted</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *old_domain, <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *new_domain, <a class="el" href="forestclaw3d_8h.html#a7e7e5dcadc6cc6b2f6bbff4d9894fb89">fclaw3d_match_callback_t</a> mcb, void *user)</td></tr>
<tr class="memdesc:acc7c71d9ac7b47562f078c9a8434ff9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the previous and the adapted domain simultaneously.  <a href="forestclaw3d_8h.html#acc7c71d9ac7b47562f078c9a8434ff9d">More...</a><br /></td></tr>
<tr class="separator:acc7c71d9ac7b47562f078c9a8434ff9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Parititon</h2></td></tr>
<tr class="memitem:a4985ae886e5e8b98d06af29a7f4a74e3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a4985ae886e5e8b98d06af29a7f4a74e3">fclaw3d_transfer_callback_t</a>) (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *old_domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *old_patch, <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *new_domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *new_patch, int blockno, int old_patchno, int new_patchno, void *user)</td></tr>
<tr class="memdesc:a4985ae886e5e8b98d06af29a7f4a74e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to iterate through the partitions.  <a href="forestclaw3d_8h.html#a4985ae886e5e8b98d06af29a7f4a74e3">More...</a><br /></td></tr>
<tr class="separator:a4985ae886e5e8b98d06af29a7f4a74e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12215a52b185bb4655de2dbb8909ca4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a12215a52b185bb4655de2dbb8909ca4a">fclaw3d_domain_allocate_before_partition</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, size_t data_size, void ***patch_data)</td></tr>
<tr class="memdesc:a12215a52b185bb4655de2dbb8909ca4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate data buffer for parallel transfer of all patches.  <a href="forestclaw3d_8h.html#a12215a52b185bb4655de2dbb8909ca4a">More...</a><br /></td></tr>
<tr class="separator:a12215a52b185bb4655de2dbb8909ca4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2939f8f594e6bde0f8c6044fd0b624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#aaf2939f8f594e6bde0f8c6044fd0b624">fclaw3d_domain_retrieve_after_partition</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, void ***patch_data)</td></tr>
<tr class="memdesc:aaf2939f8f594e6bde0f8c6044fd0b624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data buffer to reflect patch data after partition.  <a href="forestclaw3d_8h.html#aaf2939f8f594e6bde0f8c6044fd0b624">More...</a><br /></td></tr>
<tr class="separator:aaf2939f8f594e6bde0f8c6044fd0b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f777a868902b510aae90513b30887f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a3f777a868902b510aae90513b30887f0">fclaw3d_domain_iterate_partitioned</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *old_domain, <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *new_domain, <a class="el" href="forestclaw3d_8h.html#a4985ae886e5e8b98d06af29a7f4a74e3">fclaw3d_transfer_callback_t</a> tcb, void *user)</td></tr>
<tr class="memdesc:a3f777a868902b510aae90513b30887f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the previous and partitioned domain simultaneously.  <a href="forestclaw3d_8h.html#a3f777a868902b510aae90513b30887f0">More...</a><br /></td></tr>
<tr class="separator:a3f777a868902b510aae90513b30887f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53229f6654e23683c7a3a0040101bb14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a53229f6654e23683c7a3a0040101bb14">fclaw3d_domain_free_after_partition</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, void ***patch_data)</td></tr>
<tr class="memdesc:a53229f6654e23683c7a3a0040101bb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free buffers that were used in transfering data during partition.  <a href="forestclaw3d_8h.html#a53229f6654e23683c7a3a0040101bb14">More...</a><br /></td></tr>
<tr class="separator:a53229f6654e23683c7a3a0040101bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Exchange</h2></td></tr>
<tr class="memitem:ab21c5cb65d153e69c9cd02973a0addb8"><td class="memItemLeft" align="right" valign="top"><a id="ab21c5cb65d153e69c9cd02973a0addb8"></a>
typedef struct <a class="el" href="structfclaw3d__domain__exchange.html">fclaw3d_domain_exchange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a></td></tr>
<tr class="memdesc:ab21c5cb65d153e69c9cd02973a0addb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for storing allocated data for parallel exchange. <br /></td></tr>
<tr class="separator:ab21c5cb65d153e69c9cd02973a0addb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a3cb6fda1cce6018c7ce9be916c6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a50a3cb6fda1cce6018c7ce9be916c6fe">fclaw3d_domain_allocate_before_exchange</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, size_t data_size)</td></tr>
<tr class="memdesc:a50a3cb6fda1cce6018c7ce9be916c6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate buffer to hold the data from off-processor patches.  <a href="forestclaw3d_8h.html#a50a3cb6fda1cce6018c7ce9be916c6fe">More...</a><br /></td></tr>
<tr class="separator:a50a3cb6fda1cce6018c7ce9be916c6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aae576026a601d4e42dda0b7f6b8547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a7aae576026a601d4e42dda0b7f6b8547">fclaw3d_domain_ghost_exchange</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a> *e, int exchange_minlevel, int exchange_maxlevel)</td></tr>
<tr class="memdesc:a7aae576026a601d4e42dda0b7f6b8547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange data for parallel ghost neighbors.  <a href="forestclaw3d_8h.html#a7aae576026a601d4e42dda0b7f6b8547">More...</a><br /></td></tr>
<tr class="separator:a7aae576026a601d4e42dda0b7f6b8547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6d24c130b6c001112fe98da35d7f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a4e6d24c130b6c001112fe98da35d7f2c">fclaw3d_domain_ghost_exchange_begin</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a> *e, int exchange_minlevel, int exchange_maxlevel)</td></tr>
<tr class="memdesc:a4e6d24c130b6c001112fe98da35d7f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous exchange of parallel ghost neighbors.  <a href="forestclaw3d_8h.html#a4e6d24c130b6c001112fe98da35d7f2c">More...</a><br /></td></tr>
<tr class="separator:a4e6d24c130b6c001112fe98da35d7f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf51aec479e8fafb5a761c66d3717bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#aacf51aec479e8fafb5a761c66d3717bb">fclaw3d_domain_ghost_exchange_end</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a> *e)</td></tr>
<tr class="memdesc:aacf51aec479e8fafb5a761c66d3717bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete asynchronous exchange of parallel ghost neighbors.  <a href="forestclaw3d_8h.html#aacf51aec479e8fafb5a761c66d3717bb">More...</a><br /></td></tr>
<tr class="separator:aacf51aec479e8fafb5a761c66d3717bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7e68a7ad14e9a9f9103f1b684a1501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a8d7e68a7ad14e9a9f9103f1b684a1501">fclaw3d_domain_free_after_exchange</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a> *e)</td></tr>
<tr class="memdesc:a8d7e68a7ad14e9a9f9103f1b684a1501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free buffers used in exchanging off-processor data during time stepping.  <a href="forestclaw3d_8h.html#a8d7e68a7ad14e9a9f9103f1b684a1501">More...</a><br /></td></tr>
<tr class="separator:a8d7e68a7ad14e9a9f9103f1b684a1501"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Indirect Parallel Neighbors</h2></td></tr>
<tr class="memitem:a41426e838b0171f39085031ad8d843c8"><td class="memItemLeft" align="right" valign="top">typedef struct fclaw3d_domain_indirect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a></td></tr>
<tr class="memdesc:a41426e838b0171f39085031ad8d843c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin sending messages to determine neighbors of ghost patches.  <a href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">More...</a><br /></td></tr>
<tr class="separator:a41426e838b0171f39085031ad8d843c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ca0f5110f115c862217d684faa3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a7f5ca0f5110f115c862217d684faa3e8">fclaw3d_domain_indirect_begin</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a7f5ca0f5110f115c862217d684faa3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin sending messages to determine neighbors of ghost patches.  <a href="forestclaw3d_8h.html#a7f5ca0f5110f115c862217d684faa3e8">More...</a><br /></td></tr>
<tr class="separator:a7f5ca0f5110f115c862217d684faa3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3668820c5ce03b7949fe1133a82d8493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a3668820c5ce03b7949fe1133a82d8493">fclaw3d_domain_indirect_end</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a> *ind)</td></tr>
<tr class="memdesc:a3668820c5ce03b7949fe1133a82d8493"><td class="mdescLeft">&#160;</td><td class="mdescRight">End sending messages to determine neighbors of ghost patches.  <a href="forestclaw3d_8h.html#a3668820c5ce03b7949fe1133a82d8493">More...</a><br /></td></tr>
<tr class="separator:a3668820c5ce03b7949fe1133a82d8493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53dcd09483539274459936a3491e605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#af53dcd09483539274459936a3491e605">fclaw3d_domain_indirect_face_neighbors</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a> *ind, int ghostno, int faceno, int rproc[4], int *rblockno, int rpatchno[4], int *rfaceno)</td></tr>
<tr class="memdesc:af53dcd09483539274459936a3491e605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this analogously to <a class="el" href="forestclaw3d_8h.html#ad0627be8e5090b99c487354e4ae2e7eb">fclaw3d_patch_face_neighbors</a>.  <a href="forestclaw3d_8h.html#af53dcd09483539274459936a3491e605">More...</a><br /></td></tr>
<tr class="separator:af53dcd09483539274459936a3491e605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78e3594db72e79d0e5d5a5ff624c5bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#ad78e3594db72e79d0e5d5a5ff624c5bd">fclaw3d_domain_indirect_corner_neighbor</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a> *ind, int ghostno, int cornerno, int *rproc, int *rblockno, int *rpatchno, int *rcornerno)</td></tr>
<tr class="memdesc:ad78e3594db72e79d0e5d5a5ff624c5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this analogously to <a class="el" href="forestclaw3d_8h.html#a8b5c6a52789aa179658ad03ee7f72c8d">fclaw3d_patch_corner_neighbors</a>.  <a href="forestclaw3d_8h.html#ad78e3594db72e79d0e5d5a5ff624c5bd">More...</a><br /></td></tr>
<tr class="separator:ad78e3594db72e79d0e5d5a5ff624c5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6359e691f86f0fb6e47a95f3550f39db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a6359e691f86f0fb6e47a95f3550f39db">fclaw3d_domain_indirect_destroy</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a> *ind)</td></tr>
<tr class="memdesc:a6359e691f86f0fb6e47a95f3550f39db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all context data for indirect ghost neighbor patches.  <a href="forestclaw3d_8h.html#a6359e691f86f0fb6e47a95f3550f39db">More...</a><br /></td></tr>
<tr class="separator:a6359e691f86f0fb6e47a95f3550f39db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Communication</h2></td></tr>
<tr class="memitem:a84cdf960ad37808e85d930e0142ffaa1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a84cdf960ad37808e85d930e0142ffaa1">fclaw3d_domain_global_maximum</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, double d)</td></tr>
<tr class="memdesc:a84cdf960ad37808e85d930e0142ffaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the maximum over all processors of a double value.  <a href="forestclaw3d_8h.html#a84cdf960ad37808e85d930e0142ffaa1">More...</a><br /></td></tr>
<tr class="separator:a84cdf960ad37808e85d930e0142ffaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401433f80c9ee48074327735f69f4086"><td class="memItemLeft" align="right" valign="top"><a id="a401433f80c9ee48074327735f69f4086"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a401433f80c9ee48074327735f69f4086">fclaw3d_domain_global_sum</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, double d)</td></tr>
<tr class="memdesc:a401433f80c9ee48074327735f69f4086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the sum over all processors of a double value. <br /></td></tr>
<tr class="separator:a401433f80c9ee48074327735f69f4086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc04595b7e3fcd1ea5bd84212f8a4f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#aebc04595b7e3fcd1ea5bd84212f8a4f1">fclaw3d_domain_barrier</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:aebc04595b7e3fcd1ea5bd84212f8a4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize all processes.  <a href="forestclaw3d_8h.html#aebc04595b7e3fcd1ea5bd84212f8a4f1">More...</a><br /></td></tr>
<tr class="separator:aebc04595b7e3fcd1ea5bd84212f8a4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642b0bee90b7d8749d4bebd5bfbf246b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a642b0bee90b7d8749d4bebd5bfbf246b">fclaw3d_domain_serialization_enter</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a642b0bee90b7d8749d4bebd5bfbf246b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a section of code.  <a href="forestclaw3d_8h.html#a642b0bee90b7d8749d4bebd5bfbf246b">More...</a><br /></td></tr>
<tr class="separator:a642b0bee90b7d8749d4bebd5bfbf246b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357a4f863e41ddb04720937c7dac2bde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a357a4f863e41ddb04720937c7dac2bde">fclaw3d_domain_serialization_leave</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a357a4f863e41ddb04720937c7dac2bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a section of code.  <a href="forestclaw3d_8h.html#a357a4f863e41ddb04720937c7dac2bde">More...</a><br /></td></tr>
<tr class="separator:a357a4f863e41ddb04720937c7dac2bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Meta Domains</h2></td></tr>
<tr class="memitem:a4985d446cbdbe511abe9fe64b3ee37f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#a4985d446cbdbe511abe9fe64b3ee37f3">fclaw3d_domain_is_meta</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a4985d446cbdbe511abe9fe64b3ee37f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>domain</em> is an artifical domain.  <a href="forestclaw3d_8h.html#a4985d446cbdbe511abe9fe64b3ee37f3">More...</a><br /></td></tr>
<tr class="separator:a4985d446cbdbe511abe9fe64b3ee37f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5abb130e50d42b8cf6bf78e43da3a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw3d_8h.html#acc5abb130e50d42b8cf6bf78e43da3a1">fclaw3d_domain_init_meta</a> (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, int mpirank)</td></tr>
<tr class="memdesc:acc5abb130e50d42b8cf6bf78e43da3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a meta domain.  <a href="forestclaw3d_8h.html#acc5abb130e50d42b8cf6bf78e43da3a1">More...</a><br /></td></tr>
<tr class="separator:acc5abb130e50d42b8cf6bf78e43da3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main ForestClaw structures and routines </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a41426e838b0171f39085031ad8d843c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41426e838b0171f39085031ad8d843c8">&#9670;&nbsp;</a></span>fclaw3d_domain_indirect_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fclaw3d_domain_indirect <a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin sending messages to determine neighbors of ghost patches. </p>
<p>This call must not be interleaved with any ghost_exchange calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>This domain must remain valid until <a class="el" href="forestclaw3d_8h.html#a6359e691f86f0fb6e47a95f3550f39db">fclaw3d_domain_indirect_destroy</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A private data structure that will hold the context for indirect ghost neighbors. </dd></dl>

</div>
</div>
<a id="a7e7e5dcadc6cc6b2f6bbff4d9894fb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7e5dcadc6cc6b2f6bbff4d9894fb89">&#9670;&nbsp;</a></span>fclaw3d_match_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fclaw3d_match_callback_t) (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *old_domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *old_patch, <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *new_domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *new_patch, <a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a> newsize, int blockno, int old_patchno, int new_patchno, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback prototype used in fclaw3d_domain_iterate_adapted. </p>
<p>The newsize value informs on refine/coarsen/noop status. If refined (new patch is HALFSIZE), the old patch is old_patch[0] and the new patches are given by new_patch[0] through new_patch[3]. The new_patchno numbers are consecutive as well. If noop (new patch is SAMESIZE), only old_patch[0] and new_patch[0] matter. If coarsened (new patch is DOUBLESIZE), situation is the reverse of refine. We iterate over local patches only. </p>

</div>
</div>
<a id="ac5178a0f55aaa5e3ad02dc2913c94c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5178a0f55aaa5e3ad02dc2913c94c47">&#9670;&nbsp;</a></span>fclaw3d_patch_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fclaw3d_patch_callback_t) (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *patch, int blockno, int patchno, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback prototype for the patch iterators. </p>
<p>We iterate over local patches only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>General domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>The local patch currently processed by the iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Block number of processed patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Patch number within block of processed patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Data that was passed into the iterator functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4985ae886e5e8b98d06af29a7f4a74e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4985ae886e5e8b98d06af29a7f4a74e3">&#9670;&nbsp;</a></span>fclaw3d_transfer_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fclaw3d_transfer_callback_t) (<a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *old_domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *old_patch, <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *new_domain, <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *new_patch, int blockno, int old_patchno, int new_patchno, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to iterate through the partitions. </p>
<p>We traverse every patch in the new partition. If that patch was already on the local processor before the partition, we identify its memory. We iterate over local patches only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">old_domain</td><td>Domain before partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">old_patch</td><td>If the patch stayed local, this is the pointer in reference to the old domain and partition. Otherwise, this patch pointer is set to NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_domain</td><td>Domain after partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_patch</td><td>Patch in the new domain and partition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the current block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_patchno</td><td>Number of the patch that stayed local wrt. the old domain and partition. Minus one otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_patchno</td><td>Number of the iterated patch wrt. the new domain and partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Pointer passed to <a class="el" href="forestclaw3d_8h.html#a3f777a868902b510aae90513b30887f0">fclaw3d_domain_iterate_partitioned</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae60c1ef0c79a8f9373dd914c1acdd5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60c1ef0c79a8f9373dd914c1acdd5d3">&#9670;&nbsp;</a></span>fclaw3d_face_neighbor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="forestclaw3d_8h.html#ae60c1ef0c79a8f9373dd914c1acdd5d3">fclaw3d_face_neighbor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of face neighbor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae60c1ef0c79a8f9373dd914c1acdd5d3a7f47f7f3afedb3dae78cf255101b3a4a"></a>FCLAW3D_PATCH_BOUNDARY&#160;</td><td class="fielddoc"><p>Physical boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae60c1ef0c79a8f9373dd914c1acdd5d3aa8554a9fb0474061513aea8495c39243"></a>FCLAW3D_PATCH_HALFSIZE&#160;</td><td class="fielddoc"><p>Half-size (finer) neighbor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae60c1ef0c79a8f9373dd914c1acdd5d3a249f2cda59583db9150ce755990a47c6"></a>FCLAW3D_PATCH_SAMESIZE&#160;</td><td class="fielddoc"><p>Same-size neighbor. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae60c1ef0c79a8f9373dd914c1acdd5d3aa8e08f79558d4bab161d1ac012090c85"></a>FCLAW3D_PATCH_DOUBLESIZE&#160;</td><td class="fielddoc"><p>Double-size (coarser) neighbor. </p>
</td></tr>
</table>

</div>
</div>
<a id="a53c832f258cd7cd2ceb5f3a088700021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c832f258cd7cd2ceb5f3a088700021">&#9670;&nbsp;</a></span>fclaw3d_patch_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="forestclaw3d_8h.html#a53c832f258cd7cd2ceb5f3a088700021">fclaw3d_patch_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for encoding patch information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021ad932443c340617e3917b60694240cad0"></a>FCLAW3D_PATCH_CHILDID&#160;</td><td class="fielddoc"><p>Number relative to parent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021aa8f1c1dca91c75f0e217007b9b1cf14f"></a>FCLAW3D_PATCH_FIRST_SIBLING&#160;</td><td class="fielddoc"><p>Patch is the first sibling. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021ae2b76edb00ff1fdcd19794278f38ea62"></a>FCLAW3D_PATCH_ON_PARALLEL_BOUNDARY&#160;</td><td class="fielddoc"><p>Has neighbor on different processor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021a5f7c4ebabe3670c770b709fdce36d1af"></a>FCLAW3D_PATCH_IS_GHOST&#160;</td><td class="fielddoc"><p>Patch is a ghost patch. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021ac8dd2dca6249334382c2e76a2761cca5"></a>FCLAW3D_PATCH_ON_BLOCK_FACE_0&#160;</td><td class="fielddoc"><p>Face 0 is on a block boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021a1f51826c6a98f91ede300dd08b1f55a8"></a>FCLAW3D_PATCH_ON_BLOCK_FACE_1&#160;</td><td class="fielddoc"><p>Face 1 is on a block boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021a3a47fba116bb81627cbd6fa03bc8d25c"></a>FCLAW3D_PATCH_ON_BLOCK_FACE_2&#160;</td><td class="fielddoc"><p>Face 2 is on a block boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021a8b0196ef611879f5905c42f245a7edfe"></a>FCLAW3D_PATCH_ON_BLOCK_FACE_3&#160;</td><td class="fielddoc"><p>Face 3 is on a block boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021a29f6dd2640a2314f7de4cf07014b0aa7"></a>FCLAW3D_PATCH_ON_BLOCK_FACE_4&#160;</td><td class="fielddoc"><p>Face 4 is on a block boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021a25dd39dd7f1d5e56c35b681246e01289"></a>FCLAW3D_PATCH_ON_BLOCK_FACE_5&#160;</td><td class="fielddoc"><p>Face 5 is on a block boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53c832f258cd7cd2ceb5f3a088700021aebcd1628615a82cc3de0998e2da97d12"></a>FCLAW3D_PATCH_ON_BLOCK_BOUNDARY&#160;</td><td class="fielddoc"><p>Patch is on a block boundary. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a50a3cb6fda1cce6018c7ce9be916c6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a3cb6fda1cce6018c7ce9be916c6fe">&#9670;&nbsp;</a></span>fclaw3d_domain_allocate_before_exchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a>* fclaw3d_domain_allocate_before_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate buffer to hold the data from off-processor patches. </p>
<p>Free this by fclaw3d_domain_free_after_exchange before regridding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain is not modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Number of bytes per patch to exchange. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated data structure. The pointers in patch_data[i] need to be set after this call by forestclaw. </dd></dl>

</div>
</div>
<a id="a12215a52b185bb4655de2dbb8909ca4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12215a52b185bb4655de2dbb8909ca4a">&#9670;&nbsp;</a></span>fclaw3d_domain_allocate_before_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_allocate_before_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>patch_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate data buffer for parallel transfer of all patches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>The memory lives inside this domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Number of bytes per patch to transfer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">patch_data</td><td>Address of an array of void pointers. Data is allocated by this function. After the call, *patch_data holds one pointer per patch that points to exactly data_size bytes of memory that can be written to by forestclaw. *patch_data must be NULL before the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a885a030ef869a7399e1a922c3f7eaa31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885a030ef869a7399e1a922c3f7eaa31">&#9670;&nbsp;</a></span>fclaw3d_domain_attribute_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fclaw3d_domain_attribute_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>default_attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a named attribute of the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain may or may not have the queried attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The attribute by this <em>name</em> is retrieved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_attr</td><td>Returned if the attribute does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data that was previously stored under <em>name</em>, or <em>default_attr</em> if the attribute does not exist. </dd></dl>

</div>
</div>
<a id="a0b105bb68f4cd87f571b4d965b966d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b105bb68f4cd87f571b4d965b966d48">&#9670;&nbsp;</a></span>fclaw3d_domain_attribute_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_attribute_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>attribute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a named attribute to the domain. </p>
<p>Attribute names starting with 'fclaw' are reserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>This domain will get a new attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>This name must not yet be used for another attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute</td><td>Arbitrary data stored under <em>name</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebbb62f54aa61f0c298868469734ec42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbb62f54aa61f0c298868469734ec42">&#9670;&nbsp;</a></span>fclaw3d_domain_attribute_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_attribute_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a named attribute from the domain. </p>
<p>It is NOT necessary to call this function before domain destruction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain must have the attribute <em>name</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>An attribute of this name must exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebc04595b7e3fcd1ea5bd84212f8a4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc04595b7e3fcd1ea5bd84212f8a4f1">&#9670;&nbsp;</a></span>fclaw3d_domain_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize all processes. </p>
<p>Avoid using if at all possible. </p>

</div>
</div>
<a id="a8d7e68a7ad14e9a9f9103f1b684a1501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7e68a7ad14e9a9f9103f1b684a1501">&#9670;&nbsp;</a></span>fclaw3d_domain_free_after_exchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_free_after_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free buffers used in exchanging off-processor data during time stepping. </p>
<p>This should be done just before regridding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain is not modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Allocated buffers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53229f6654e23683c7a3a0040101bb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53229f6654e23683c7a3a0040101bb14">&#9670;&nbsp;</a></span>fclaw3d_domain_free_after_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_free_after_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>patch_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free buffers that were used in transfering data during partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>The memory lives inside this domain. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">patch_data</td><td>Address of an array of void pointers to free. *patch_data will be NULL after the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aae576026a601d4e42dda0b7f6b8547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aae576026a601d4e42dda0b7f6b8547">&#9670;&nbsp;</a></span>fclaw3d_domain_ghost_exchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_ghost_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exchange_minlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exchange_maxlevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange data for parallel ghost neighbors. </p>
<p>This function receives data from parallel neighbor (ghost) patches. It can be called multiple times on the same allocated buffers. We assume that the data size for all patches is the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Used to access forest and ghost metadata. #(sent patches) is domain-&gt;num_exchange_patches. #(received patches) is domain-&gt;num_ghost_patches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Allocated buffers whose e-&gt;patch_data[i] pointers must have been set properly by forestclaw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exchange_minlevel</td><td>The minimum quadrant level that is exchanged. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exchange_maxlevel</td><td>The maximum quadrant level that is exchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e6d24c130b6c001112fe98da35d7f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6d24c130b6c001112fe98da35d7f2c">&#9670;&nbsp;</a></span>fclaw3d_domain_ghost_exchange_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_ghost_exchange_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exchange_minlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exchange_maxlevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous exchange of parallel ghost neighbors. </p>
<p>The arguments are the same as for fclaw3d_domain_ghost_exchange. It must be followed by a call to fclaw3d_domain_ghost_exchange_end. Between begin and end, neither of <a class="el" href="forestclaw3d_8h.html#a7f5ca0f5110f115c862217d684faa3e8">fclaw3d_domain_indirect_begin</a> and _end must be called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>Its ghost_data member must survive and not be written to until the completion of fclaw3d_domain_ghost_exchange_end. Its patch_data member may already be overwritten after this function returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacf51aec479e8fafb5a761c66d3717bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf51aec479e8fafb5a761c66d3717bb">&#9670;&nbsp;</a></span>fclaw3d_domain_ghost_exchange_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_ghost_exchange_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#ab21c5cb65d153e69c9cd02973a0addb8">fclaw3d_domain_exchange_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete asynchronous exchange of parallel ghost neighbors. </p>
<p>Must be called at some point after fclaw3d_domain_ghost_exchange_begin. Between begin and end, neither of <a class="el" href="forestclaw3d_8h.html#a7f5ca0f5110f115c862217d684faa3e8">fclaw3d_domain_indirect_begin</a> and _end must be called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>Its ghost_data member must have survived. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84cdf960ad37808e85d930e0142ffaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cdf960ad37808e85d930e0142ffaa1">&#9670;&nbsp;</a></span>fclaw3d_domain_global_maximum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fclaw3d_domain_global_maximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and return the maximum over all processors of a double value. </p>
<p>The minimum can be computed by using this function on the negative value. </p>

</div>
</div>
<a id="a7f5ca0f5110f115c862217d684faa3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5ca0f5110f115c862217d684faa3e8">&#9670;&nbsp;</a></span>fclaw3d_domain_indirect_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a>* fclaw3d_domain_indirect_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin sending messages to determine neighbors of ghost patches. </p>
<p>This call must not be interleaved with any ghost_exchange calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>This domain must remain valid until <a class="el" href="forestclaw3d_8h.html#a6359e691f86f0fb6e47a95f3550f39db">fclaw3d_domain_indirect_destroy</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A private data structure that will hold the context for indirect ghost neighbors. </dd></dl>

</div>
</div>
<a id="ad78e3594db72e79d0e5d5a5ff624c5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e3594db72e79d0e5d5a5ff624c5bd">&#9670;&nbsp;</a></span>fclaw3d_domain_indirect_corner_neighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a> fclaw3d_domain_indirect_corner_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a> *&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ghostno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cornerno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rblockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rpatchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rcornerno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this analogously to <a class="el" href="forestclaw3d_8h.html#a8b5c6a52789aa179658ad03ee7f72c8d">fclaw3d_patch_corner_neighbors</a>. </p>
<p>Return an indirect corner neighbor patch: It is defined as a ghost patch that is corner neighbor to the calling ghost patch and belongs to a process that is neither the owner of that ghost patch nor our own process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Must be the same domain used in begin and end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ind</td><td>Must have been initialized by <a class="el" href="forestclaw3d_8h.html#a3668820c5ce03b7949fe1133a82d8493">fclaw3d_domain_indirect_end</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghostno</td><td>Number of the ghost patch whose neighbor we seek. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cornerno</td><td>Number of the ghost patch's corner to look across. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rproc</td><td>Processor number of neighbor patch. Exception: For non-indirect patches, set it to -1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rblockno</td><td>The number of the neighbor block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpatchno</td><td>Only for indirect ghost patches, we store the number relative to our ghost patch array. For all other patches, this is -1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rcornerno</td><td>The corner number of the neighbor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Only for indirect ghost patches, the size of the neighbor. For all others, we set this to <a class="el" href="forestclaw2d_8h.html#ad168236647aee6aac7e0fd77173a77d2a12d0015136e82f61e79b827b60386753">FCLAW2D_PATCH_BOUNDARY</a>. </dd></dl>

</div>
</div>
<a id="a6359e691f86f0fb6e47a95f3550f39db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6359e691f86f0fb6e47a95f3550f39db">&#9670;&nbsp;</a></span>fclaw3d_domain_indirect_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_indirect_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a> *&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy all context data for indirect ghost neighbor patches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Must be the same domain used in begin and end. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ind</td><td>Memory will be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3668820c5ce03b7949fe1133a82d8493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3668820c5ce03b7949fe1133a82d8493">&#9670;&nbsp;</a></span>fclaw3d_domain_indirect_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_indirect_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a> *&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End sending messages to determine neighbors of ghost patches. </p>
<p>This call must not be interleaved with any ghost_exchange calls. When this function returns, the necessary information is complete and fclaw3d_domain_indirect_face neighbors and <a class="el" href="forestclaw3d_8h.html#ad78e3594db72e79d0e5d5a5ff624c5bd">fclaw3d_domain_indirect_corner_neighbor</a> may be called any number of times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Must be the same domain used in the begin call. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ind</td><td>Must be returned by an earlier call to <a class="el" href="forestclaw3d_8h.html#a7f5ca0f5110f115c862217d684faa3e8">fclaw3d_domain_indirect_begin</a> and will be completed with parallel information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af53dcd09483539274459936a3491e605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53dcd09483539274459936a3491e605">&#9670;&nbsp;</a></span>fclaw3d_domain_indirect_face_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a> fclaw3d_domain_indirect_face_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a41426e838b0171f39085031ad8d843c8">fclaw3d_domain_indirect_t</a> *&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ghostno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rproc</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rblockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rpatchno</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rfaceno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this analogously to <a class="el" href="forestclaw3d_8h.html#ad0627be8e5090b99c487354e4ae2e7eb">fclaw3d_patch_face_neighbors</a>. </p>
<p>We only return an indirect ghost neighbor patch: This is defined as a ghost patch that is neighbor to the calling ghost patch and belongs to a processor that is neither the owner of that ghost patch nor our own processor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Must be the same domain used in begin and end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ind</td><td>Must have been initialized by <a class="el" href="forestclaw3d_8h.html#a3668820c5ce03b7949fe1133a82d8493">fclaw3d_domain_indirect_end</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghostno</td><td>Number of the ghost patch whose neighbors we seek. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceno</td><td>Number of the ghost patch's face to look across. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rproc</td><td>Processor number of neighbor patches. Exception 1: If the neighbor is a bigger patch, rproc[1] contains the number of the small patch as one of four half faces, but only if the neighbor fits the above criteria. Exception 2: For non-indirect patches, set it to -1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rblockno</td><td>The number of the neighbor block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpatchno</td><td>Only for indirect ghost patches, we store the number relative to our ghost patch array. For all other patches, this is -1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rfaceno</td><td>The face number and orientation of the neighbor(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Only for indirect ghost patches, the size of the neighbor(s). For all others, we set this to <a class="el" href="forestclaw3d_8h.html#ae60c1ef0c79a8f9373dd914c1acdd5d3a7f47f7f3afedb3dae78cf255101b3a4a">FCLAW3D_PATCH_BOUNDARY</a>. </dd></dl>

</div>
</div>
<a id="acc5abb130e50d42b8cf6bf78e43da3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5abb130e50d42b8cf6bf78e43da3a1">&#9670;&nbsp;</a></span>fclaw3d_domain_init_meta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_init_meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mpirank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a meta domain. </p>
<p>Initializes <em>domain</em> in an artificial manner, where the entry mpirank is used to store arbitrary context information. The remaining entries are initialized to -1 or NULL. The resulting domain can be passed to an fclaw3d_interpolate_point_t in case the domain to interpolate on is not available locally (also see fclaw3d_overlap_exchange for an example). </p>

</div>
</div>
<a id="a4985d446cbdbe511abe9fe64b3ee37f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4985d446cbdbe511abe9fe64b3ee37f3">&#9670;&nbsp;</a></span>fclaw3d_domain_is_meta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_domain_is_meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <em>domain</em> is an artifical domain. </p>
<p>This function can be used in fclaw3d_interpolate_point_t callbacks to distinguish domains that were created during a partition search (and only contain some meta information) from real domains in a local search. </p>

</div>
</div>
<a id="acc7c71d9ac7b47562f078c9a8434ff9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7c71d9ac7b47562f078c9a8434ff9d">&#9670;&nbsp;</a></span>fclaw3d_domain_iterate_adapted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_iterate_adapted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>old_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>new_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a7e7e5dcadc6cc6b2f6bbff4d9894fb89">fclaw3d_match_callback_t</a>&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the previous and the adapted domain simultaneously. </p>
<p>We iterate over local patches only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">old_domain</td><td>Domain before adaptation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_domain</td><td>Domain after adaptation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mcb</td><td>Callback. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>This pointer is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af61f45710072a667e3a7a42af55fe621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61f45710072a667e3a7a42af55fe621">&#9670;&nbsp;</a></span>fclaw3d_domain_iterate_families()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_iterate_families </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#ac5178a0f55aaa5e3ad02dc2913c94c47">fclaw3d_patch_callback_t</a>&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all families of local sibling patches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>General domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcb</td><td>Function called for each family in the domain. Its patch argument points to an array of eight valid patches that constitute a family of siblings. Their patchnos are consecutive, blockno is the same. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Data is passed to the pcb callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10b442159e00a854483ab606f4e0f271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b442159e00a854483ab606f4e0f271">&#9670;&nbsp;</a></span>fclaw3d_domain_iterate_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_iterate_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#ac5178a0f55aaa5e3ad02dc2913c94c47">fclaw3d_patch_callback_t</a>&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all local patches on a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>General domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level to iterate. Ignore patches of other levels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcb</td><td>Function called for each patch of matching level. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Data is passed to the pcb callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f777a868902b510aae90513b30887f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f777a868902b510aae90513b30887f0">&#9670;&nbsp;</a></span>fclaw3d_domain_iterate_partitioned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_iterate_partitioned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>old_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>new_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a4985ae886e5e8b98d06af29a7f4a74e3">fclaw3d_transfer_callback_t</a>&#160;</td>
          <td class="paramname"><em>tcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the previous and partitioned domain simultaneously. </p>
<p>We iterate over local patches only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">old_domain</td><td>Domain before partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_domain</td><td>Domain after partition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcb</td><td>Callback. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>This pointer is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab44625472baca44e82f30d7709a3b113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44625472baca44e82f30d7709a3b113">&#9670;&nbsp;</a></span>fclaw3d_domain_iterate_patches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_iterate_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#ac5178a0f55aaa5e3ad02dc2913c94c47">fclaw3d_patch_callback_t</a>&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all local patches of all levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>General domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcb</td><td>Function called for each patch in the domain. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Data is passed to the pcb callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd84e237e9c375468a882345ff03ad6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd84e237e9c375468a882345ff03ad6a">&#9670;&nbsp;</a></span>fclaw3d_domain_num_corners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_domain_num_corners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of corners of a cube: 4 in 2D, 8 in 3D. </p>
<p>This is the same as the number of siblings in a refined tree. </p>

</div>
</div>
<a id="a0a5e8c39a9e63067c590299dba173da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5e8c39a9e63067c590299dba173da6">&#9670;&nbsp;</a></span>fclaw3d_domain_num_face_corners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_domain_num_face_corners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of corners of a cube face: 2 in 2D, 4 in 3D. </p>
<p>This is the same as the number of refined (smaller) face neighbors. </p>

</div>
</div>
<a id="af16b9ea129ca8d92d0a281aaad24db4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16b9ea129ca8d92d0a281aaad24db4f">&#9670;&nbsp;</a></span>fclaw3d_domain_num_orientations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_domain_num_orientations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of possible orientations of a cube face. </p>
<p>This is mostly used for internal encodings. </p>

</div>
</div>
<a id="aaf2939f8f594e6bde0f8c6044fd0b624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2939f8f594e6bde0f8c6044fd0b624">&#9670;&nbsp;</a></span>fclaw3d_domain_retrieve_after_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_retrieve_after_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>patch_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data buffer to reflect patch data after partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>The memory lives inside this domain. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">patch_data</td><td>Address of an array of void pointers. Data is reallocated by this function. After the call, *patch_data holds one pointer per patch that points to exactly data_size bytes of memory that can be read from by forestclaw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a642b0bee90b7d8749d4bebd5bfbf246b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642b0bee90b7d8749d4bebd5bfbf246b">&#9670;&nbsp;</a></span>fclaw3d_domain_serialization_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_serialization_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a section of code. </p>
<p>THIS IS NOT SCALABLE. WILL BE HORRIBLY SLOW FOR LARGE NUMBERS OF PROCESSORS. A processor returns from this function only after all lower-numbered processors have called fclaw3d_domain_serialization_leave. No collective communication routines must be called between the calls to this function and fclaw3d_domain_serialization_leave. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain is not modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a357a4f863e41ddb04720937c7dac2bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357a4f863e41ddb04720937c7dac2bde">&#9670;&nbsp;</a></span>fclaw3d_domain_serialization_leave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_serialization_leave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a section of code. </p>
<p>THIS IS NOT SCALABLE. WILL BE HORRIBLY SLOW FOR LARGE NUMBERS OF PROCESSORS. A processor must call this function to allow all higher-numbered processors to return from fclaw3d_domain_serialization_enter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain is not modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb5de9b9ca73b4ac6ac9ac61c1f8b7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5de9b9ca73b4ac6ac9ac61c1f8b7c0">&#9670;&nbsp;</a></span>fclaw3d_domain_set_refinement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_domain_set_refinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smooth_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smooth_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarsen_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set parameters of refinement strategy in a domain. </p>
<p>This function only needs to be called once, and only for the first domain created in the program. The values of the parameters are automatically transferred on adaptation and partitioning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>This domain's refinement strategy is set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smooth_refine</td><td>Activate or deactivete refinement smoothing. A newly created domain has this set to false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smooth_level</td><td>If <b>smooth_refine</b> is true, denotes the lowest level that activates the smoothing. Use zero for smoothing across all levels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarsen_delay</td><td>Non-negative number to set the delay for coarsening after a patch has been last refined. This number is a global threshold that is compared against each patch's individual counter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6406ad1faf09b320a7b20b483d7a1b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6406ad1faf09b320a7b20b483d7a1b29">&#9670;&nbsp;</a></span>fclaw3d_patch_boundary_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_patch_boundary_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>boundaries</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine physical boundary status as 1, or 0 for neighbor patches. </p>
<p>This must ONLY be called for local patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">boundaries</td><td>Domain boundary boolean flags. The order is left, right, front, back, bottom, top. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one patch face is on a boundary. </dd></dl>

</div>
</div>
<a id="a47abd0a72ee1585ee63cf3be63661013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47abd0a72ee1585ee63cf3be63661013">&#9670;&nbsp;</a></span>fclaw3d_patch_childid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_patch_childid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of a patch with respect to its parent in the tree. </p>
<p>This function is LEGAL to call for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A patch with properly set member variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child id is a number in 0..7. </dd></dl>

</div>
</div>
<a id="a550a23d8122c76b64a7f7e3820723385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550a23d8122c76b64a7f7e3820723385">&#9670;&nbsp;</a></span>fclaw3d_patch_corner_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_patch_corner_dimension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cornerno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimension of a corner. </p>
<p>This function is LEGAL to call for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A patch with properly set member variables. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cornerno</td><td>A corner number in 0..7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the corner is always at a eightfold intersection, 1 if the corner would end up in the middle of a face when there is a coarser neighbor. </dd></dl>

</div>
</div>
<a id="a8b5c6a52789aa179658ad03ee7f72c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5c6a52789aa179658ad03ee7f72c8d">&#9670;&nbsp;</a></span>fclaw3d_patch_corner_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_patch_corner_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cornerno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rblockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rpatchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rcorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a> *&#160;</td>
          <td class="paramname"><em>neighbor_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine neighbor patch(es) and orientation across a given corner. </p>
<p>The current version only supports one neighbor, i.e., no true multi-block. A query across a corner in the middle of a longer face returns the boundary. We only return corner neighbors that are not already face or edge neighbors. Inter-tree corners are only returned if the number of meeting corners is exactly eight. Nine or more are currently not supported. This must ONLY be called for local patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cornerno</td><td>Number of the patch corner: 0=bfl, ..., 7=tbr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rproc</td><td>Processor number of neighbor patch. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rblockno</td><td>Neighbor block number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpatchno</td><td>Neighbor patch number relative to the block. If the neighbor is off-processor, this is not a patch number but in [0, num_ghosts_patches[. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rcorner</td><td>Number of the corner from the other neighbor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighbor_size</td><td>The relative patch size of the neighbor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one corner neighbor exists that is not already a face neighbor. </dd></dl>

</div>
</div>
<a id="ab35f149387e74b3ffa0fab5a9e7f5125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35f149387e74b3ffa0fab5a9e7f5125">&#9670;&nbsp;</a></span>fclaw3d_patch_corner_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_corner_swap </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>cornerno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rcornerno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change perspective across a corner neighbor situation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cornerno</td><td>On input, valid corner number for a patch. On output, corner number seen from the corner neighbor patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rcornerno</td><td>On input, valid corner number as returned by fclaw3d_patch_corner_neighbors. On output, corner number seen from the corner neighbor patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaba47caa94f508f4c166020500111c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaba47caa94f508f4c166020500111c2">&#9670;&nbsp;</a></span>fclaw3d_patch_edge_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_patch_edge_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rproc</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rblockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rpatchno</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>redge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a> *&#160;</td>
          <td class="paramname"><em>neighbor_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine neighbor patch(es) and orientation across a given edge. </p>
<p>The current version only supports one neighbor, i.e., no true multi-block. A query across an edge in the middle of a longer face returns the boundary. We only return edge neighbors that are not already face neighbors. Inter-tree edges are only returned if the number of meeting edges is exactly four. Five or more are currently not supported. This must ONLY be called for local patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeno</td><td>Number of the patch edge: 4 parallel to x axis, then 4 parallel to y axis, then 4 parallel to z. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rproc</td><td>Processor number of neighbor patch. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rblockno</td><td>Neighbor block number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpatchno</td><td>Neighbor patch number of up to 2 neighbors. ` The patch number is relative to its block. If the neighbor is off-processor, this is not a patch number but in [0, num_ghosts_patches[. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">redge</td><td>Number of the edge from the other neighbor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighbor_size</td><td>The relative patch size of the neighbor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one edge neighbor exists that is not already a face neighbor. </dd></dl>

</div>
</div>
<a id="a514f04206cc463fdcd5f0a2b98861271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514f04206cc463fdcd5f0a2b98861271">&#9670;&nbsp;</a></span>fclaw3d_patch_edge_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_edge_swap </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>edgeno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>redgeno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change perspective across an edge neighbor situation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">edgeno</td><td>On input, valid edge number for a patch. On output, edge number seen from the edge neighbor patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">redgeno</td><td>On input, valid edge number as returned by fclaw3d_patch_edge_neighbors. On output, edge number seen from the edge neighbor patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0627be8e5090b99c487354e4ae2e7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0627be8e5090b99c487354e4ae2e7eb">&#9670;&nbsp;</a></span>fclaw3d_patch_face_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw3d_8h.html#a7e71ccdedcccb2178a72b97359628162">fclaw3d_patch_relation_t</a> fclaw3d_patch_face_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rproc</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rblockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rpatchno</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rfaceno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine neighbor patch(es) and orientation across a given face. </p>
<p>This must ONLY be called for local patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceno</td><td>Number of the patch face: left, right, front, back, bottom, top. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rproc</td><td>Processor number of neighbor patches. Exception: If the neighbor is a bigger patch, rproc[1] contains the number of the small patch as one of four half faces. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rblockno</td><td>Neighbor block number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpatchno</td><td>Neighbor patch numbers for up to 4 neighbors. The patch number is relative to its block. If the neighbor is off-processor, this is not a patch number but in [0, num_ghost_patches[. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rfaceno</td><td>Neighbor face number and orientation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The relative patch size of the face neighbor. </dd></dl>

</div>
</div>
<a id="a55a76479f18d385727b330b29624d77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a76479f18d385727b330b29624d77e">&#9670;&nbsp;</a></span>fclaw3d_patch_face_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_face_swap </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>faceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rfaceno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change perspective across a face neighbor situation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">faceno</td><td>On input, valid face number for a patch. On output, valid face number seen from faceno's neighbor patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rfaceno</td><td>On input, encoded neighbor face number as returned by fclaw3d_patch_face_neighbors. On output, encoded neighbor face number seen from faceno's neighbor patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71f5c76b16c4970b9f567744604886ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f5c76b16c4970b9f567744604886ed">&#9670;&nbsp;</a></span>fclaw3d_patch_face_transformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_face_transformation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rfaceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ftransform</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill an array with the axis combination of a face neighbor transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faceno</td><td>The number of the originating face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rfaceno</td><td>Encoded as rfaceno = r * 6 + nf, where nf = 0..5 is the neigbbor's connecting face number and r = 0..3 is the relative orientation to the neighbor's face. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ftransform</td><td>This array holds 9 integers. [0..2] The coordinate axis sequence of the origin face, the first two referring to the tangentials and the third to the normal. A permutation of (0, 1, 2). [3..5] The coordinate axis sequence of the target face. [6..8] Edge reversal flags for tangential axes (boolean); face code in [0, 3] for the normal coordinate q: 0: q' = -q 1: q' = q + 1 2: q' = q - 1 3: q' = 2 - q [8] &amp; 4: Both patches are in the same block, the <em>ftransform</em> contents are ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae33fc03051ea0ae4bf411a3645a0843d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33fc03051ea0ae4bf411a3645a0843d">&#9670;&nbsp;</a></span>fclaw3d_patch_face_transformation_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_face_transformation_block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ftransform</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sameblock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify an existing face transformation depending on intra-block usage. </p>
<p>This function can be called any number of times on the same transform array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ftransform</td><td>Array of values necessarily created by <a class="el" href="forestclaw3d_8h.html#a71f5c76b16c4970b9f567744604886ed">fclaw3d_patch_face_transformation</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sameblock</td><td>Transformation supposed to work in same block? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab64b13e6b92223d2c42b02e0fc0a0584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64b13e6b92223d2c42b02e0fc0a0584">&#9670;&nbsp;</a></span>fclaw3d_patch_face_transformation_intra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_face_transformation_intra </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ftransform</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill an array with the axis combination of a face neighbor transformation that operates on two patches in the same block (the trivial case). </p>
<p>Use when there is no prior call to <a class="el" href="forestclaw3d_8h.html#a71f5c76b16c4970b9f567744604886ed">fclaw3d_patch_face_transformation</a>. Don't postprocess the result any further &ndash; it's only useful intra-block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ftransform</td><td>Gets initialized to a same-block transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2e6551eca85a6da62460fc056e75a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e6551eca85a6da62460fc056e75a50">&#9670;&nbsp;</a></span>fclaw3d_patch_face_transformation_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_patch_face_transformation_valid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ftransform</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether a face transformation is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ftransform</td><td>Array of values as created by <a class="el" href="forestclaw3d_8h.html#a71f5c76b16c4970b9f567744604886ed">fclaw3d_patch_face_transformation</a>, possibly modified by <a class="el" href="forestclaw3d_8h.html#ae33fc03051ea0ae4bf411a3645a0843d">fclaw3d_patch_face_transformation_block</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if valid, false if not. </dd></dl>

</div>
</div>
<a id="a9cc11d9d86fa7f7c1f6092c86f850276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc11d9d86fa7f7c1f6092c86f850276">&#9670;&nbsp;</a></span>fclaw3d_patch_is_first_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_patch_is_first_sibling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a patch is the first in a family of eight siblings. </p>
<p>For ghost patches, we always return false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A patch with properly set member variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if patch is the first sibling. </dd></dl>

</div>
</div>
<a id="a02cc315361e4d7b86c5f14001d0a5998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cc315361e4d7b86c5f14001d0a5998">&#9670;&nbsp;</a></span>fclaw3d_patch_is_ghost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_patch_is_ghost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a patch is a parallel ghost patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A patch with properly set member variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if patch is off-processor, false if local. </dd></dl>

</div>
</div>
<a id="afef32d6d97f599b273489277011344dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef32d6d97f599b273489277011344dc">&#9670;&nbsp;</a></span>fclaw3d_patch_mark_coarsen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_mark_coarsen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a patch for coarsening. </p>
<p>This must ONLY be called for local patches. Coarsening will only happen if the patch family is not further refined and all sibling patches are marked as well. It is safe to call this function from an iterator callback except <a class="el" href="forestclaw3d_8h.html#acc7c71d9ac7b47562f078c9a8434ff9d">fclaw3d_domain_iterate_adapted</a>. </p>

</div>
</div>
<a id="a7a415c190da8fac6947eef99ea36a0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a415c190da8fac6947eef99ea36a0bf">&#9670;&nbsp;</a></span>fclaw3d_patch_mark_refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_mark_refine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a patch for refinement. </p>
<p>This must ONLY be called for local patches. It is safe to call this function from an iterator callback except <a class="el" href="forestclaw3d_8h.html#acc7c71d9ac7b47562f078c9a8434ff9d">fclaw3d_domain_iterate_adapted</a>. </p>

</div>
</div>
<a id="a0fbe20eaf00e86e4bccf418328154c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbe20eaf00e86e4bccf418328154c53">&#9670;&nbsp;</a></span>fclaw3d_patch_normal_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw3d_patch_normal_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a8be2b4fb91b07a1a8e7c475dc0ab232d">fclaw3d_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the normal to a face neighbor align. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceno</td><td>Number of the face of the patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if normals match, false for mismatch. </dd></dl>

</div>
</div>
<a id="a0141755750dd93a9d523f213bf2caac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0141755750dd93a9d523f213bf2caac8">&#9670;&nbsp;</a></span>fclaw3d_patch_transform_corner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_transform_corner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the two patches are of the SAME size and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. It is ILLEGAL to call this function for patches from face- or edge-neighboring blocks. Use <a class="el" href="forestclaw3d_8h.html#ae334a995348fd25c0d1f720484a354dd">fclaw3d_patch_transform_face</a> or <a class="el" href="forestclaw3d_8h.html#addb28a72d6304be2a11400b727c54f81">fclaw3d_patch_transform_edge</a> for such patches instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">icorner</td><td>Corner number of this patch to transform across. This function assumes ocorner == icorner ^ 7, so ocorner is the opposite corner of icorner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>Integer coordinate along x-axis in <em>based</em> .. <em>mx</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>Integer coordinate along y-axis in <em>based</em> .. <em>my</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Integer coordinate along z-axis in <em>based</em> .. <em>mz</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a27127614b26721527b3271dc72603c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a27127614b26721527b3271dc72603c">&#9670;&nbsp;</a></span>fclaw3d_patch_transform_corner2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_transform_corner2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the neighbor patch is smaller (HALF size) and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. It is ILLEGAL to call this function for patches from face- or edge-neighboring blocks. Use <a class="el" href="forestclaw3d_8h.html#a5ca37a35d7bb36f0162d089a8c2caa86">fclaw3d_patch_transform_face2</a> or <a class="el" href="forestclaw3d_8h.html#a064bfc974c8fd4fcb60565d2c2e015cc">fclaw3d_patch_transform_edge2</a> for such patches instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">icorner</td><td>Corner number of this patch to transform across. This function assumes ocorner == icorner ^ 7, so ocorner is the opposite corner of icorner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>EIGHT (8) integer coordinates along x-axis in <em>based</em> .. <em>mx</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>my</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>mz</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addb28a72d6304be2a11400b727c54f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb28a72d6304be2a11400b727c54f81">&#9670;&nbsp;</a></span>fclaw3d_patch_transform_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_transform_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iedge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the two patches are of the SAME size and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. It is ILLEGAL to call this function for patches from face-neighboring blocks. Use <a class="el" href="forestclaw3d_8h.html#ae334a995348fd25c0d1f720484a354dd">fclaw3d_patch_transform_face</a> for such patches instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iedge</td><td>Edge number of this patch to transform across. This function assumes oedge == iedge ^ 3, so oedge is the edge opposite of iedge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>Integer coordinate along x-axis in <em>based</em> .. <em>mx</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>Integer coordinate along y-axis in <em>based</em> .. <em>my</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Integer coordinate along z-axis in <em>based</em> .. <em>mz</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a064bfc974c8fd4fcb60565d2c2e015cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064bfc974c8fd4fcb60565d2c2e015cc">&#9670;&nbsp;</a></span>fclaw3d_patch_transform_edge2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_transform_edge2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iedge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the neighbor patch is smaller (HALF size) and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. It is ILLEGAL to call this function for patches from face-neighboring blocks. Use <a class="el" href="forestclaw3d_8h.html#ae334a995348fd25c0d1f720484a354dd">fclaw3d_patch_transform_face</a> for such patches instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iedge</td><td>Edge number of this patch to transform across. This function assumes oedge == iedge ^ 3, so oedge is the edge opposite of iedge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>EIGHT (8) integer coordinates along x-axis in <em>based</em> .. <em>mx</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>my</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>mz</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae334a995348fd25c0d1f720484a354dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae334a995348fd25c0d1f720484a354dd">&#9670;&nbsp;</a></span>fclaw3d_patch_transform_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_transform_face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ftransform</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the two patches are of the SAME size. If the neighbor patch is in the same block we must set (ftransform[8] &amp; 4). Else we have an input patch in one block and on output patch across a face. It is LEGAL to call this function for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ftransform</td><td>It must have room for NINE (9) integers and be computed by <em>fclaw3d_patch_face_transformation</em>. If <em>ipatch</em> and <em>opatch</em> are in the same block, we require <em>ftransform</em>[8] |= 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. The number of cells must match according to the face transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>Integer coordinate along x-axis in <em>based</em> .. <em>mx</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>Integer coordinate along y-axis in <em>based</em> .. <em>my</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Integer coordinate along z-axis in <em>based</em> .. <em>mz</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ca37a35d7bb36f0162d089a8c2caa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca37a35d7bb36f0162d089a8c2caa86">&#9670;&nbsp;</a></span>fclaw3d_patch_transform_face2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw3d_patch_transform_face2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw3d_8h.html#a54bdb11fada7424f3958509ad1ded30e">fclaw3d_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ftransform</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the neighbor patch is smaller (HALF size). If the neighbor patch is in the same block we must set (ftransform[8] &amp; 4). Else we have an input patch in one block and on output patch across a face. It is LEGAL to call this function for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ftransform</td><td>It must have room for NINE (9) integers and be computed by <em>fclaw3d_patch_face_transformation</em>. If <em>ipatch</em> and <em>opatch</em> are in the same block, we require <em>ftransform</em>[8] |= 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. The number of cells must match according to the face transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>EIGHT (8) integer coordinates along x-axis in <em>based</em> .. <em>mx</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>my</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>EIGHT (8) integer coordinates along z-axis in <em>based</em> .. <em>mz</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
