<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ForestClaw: forestclaw.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ForestClaw
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle"><div class="title">forestclaw.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main dimension independent ForestClaw structures and routines.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="fclaw__base_8h_source.html">fclaw_base.h</a>&gt;</code><br />
<code>#include &lt;sc_keyvalue.h&gt;</code><br />
</div>
<p><a href="forestclaw_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfclaw__patch.html">fclaw_patch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The metadata structure for a forest leaf, which is a forestclaw patch.  <a href="structfclaw__patch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfclaw__block.html">fclaw_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data Structure for a block.  <a href="structfclaw__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfclaw__domain.html">fclaw_domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The domain structure is a collection of blocks.  <a href="structfclaw__domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfclaw__domain__exchange.html">fclaw_domain_exchange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper struct for fclaw2d_exchange_info_t and fclaw3d_exchange_info_t.  <a href="structfclaw__domain__exchange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Patch Neighbors</h2></td></tr>
<tr class="memitem:a465096a89f3d03b85a80a8b749acc367" id="r_a465096a89f3d03b85a80a8b749acc367"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a465096a89f3d03b85a80a8b749acc367">fclaw_face_neighbor</a> { <a class="el" href="forestclaw_8h.html#a465096a89f3d03b85a80a8b749acc367acf2e88ce9be6e21da957f0a6d042cfb6">FCLAW_PATCH_BOUNDARY</a>
, <a class="el" href="forestclaw_8h.html#a465096a89f3d03b85a80a8b749acc367ad4aadb96b5b2ab498858ed98b2c1fdf7">FCLAW_PATCH_HALFSIZE</a>
, <a class="el" href="forestclaw_8h.html#a465096a89f3d03b85a80a8b749acc367acab32f867ecb3a20d50714288a0cf817">FCLAW_PATCH_SAMESIZE</a>
, <a class="el" href="forestclaw_8h.html#a465096a89f3d03b85a80a8b749acc367a7c887f8f4b477b61302beb3a48e0ff2c">FCLAW_PATCH_DOUBLESIZE</a>
 }</td></tr>
<tr class="memdesc:a465096a89f3d03b85a80a8b749acc367"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of face neighbor.  <a href="forestclaw_8h.html#a465096a89f3d03b85a80a8b749acc367">More...</a><br /></td></tr>
<tr class="separator:a465096a89f3d03b85a80a8b749acc367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af3c3bcbb77754915c4df59af3ad227" id="r_a3af3c3bcbb77754915c4df59af3ad227"><td class="memItemLeft" align="right" valign="top"><a id="a3af3c3bcbb77754915c4df59af3ad227" name="a3af3c3bcbb77754915c4df59af3ad227"></a>
typedef enum <a class="el" href="forestclaw_8h.html#a465096a89f3d03b85a80a8b749acc367">fclaw_face_neighbor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_patch_relation_t</b></td></tr>
<tr class="memdesc:a3af3c3bcbb77754915c4df59af3ad227"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of face neighbor. <br /></td></tr>
<tr class="separator:a3af3c3bcbb77754915c4df59af3ad227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799d3ba1ec94b9984173b10318b9721a" id="r_a799d3ba1ec94b9984173b10318b9721a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a799d3ba1ec94b9984173b10318b9721a">fclaw_patch_boundary_type</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int blockno, int patchno, int boundaries[])</td></tr>
<tr class="memdesc:a799d3ba1ec94b9984173b10318b9721a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine physical boundary status as 1, or 0 for neighbor patches.  <br /></td></tr>
<tr class="separator:a799d3ba1ec94b9984173b10318b9721a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d644edc13af13fa05287c4091c6f02b" id="r_a3d644edc13af13fa05287c4091c6f02b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a3d644edc13af13fa05287c4091c6f02b">fclaw_patch_normal_match</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int blockno, int patchno, int faceno)</td></tr>
<tr class="memdesc:a3d644edc13af13fa05287c4091c6f02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the normal to a face neighbor align.  <br /></td></tr>
<tr class="separator:a3d644edc13af13fa05287c4091c6f02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5277bad8d13489cdf30731657c889aab" id="r_a5277bad8d13489cdf30731657c889aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a5277bad8d13489cdf30731657c889aab">fclaw_patch_face_neighbors</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int blockno, int patchno, int faceno, int rproc[], int *rblockno, int rpatchno[], int *rfaceno)</td></tr>
<tr class="memdesc:a5277bad8d13489cdf30731657c889aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine neighbor patch(es) and orientation across a given face.  <br /></td></tr>
<tr class="separator:a5277bad8d13489cdf30731657c889aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700bfa963b6790ee4f7c0fb3e6c49cca" id="r_a700bfa963b6790ee4f7c0fb3e6c49cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a700bfa963b6790ee4f7c0fb3e6c49cca">fclaw_patch_face_swap</a> (int dim, int *faceno, int *rfaceno)</td></tr>
<tr class="memdesc:a700bfa963b6790ee4f7c0fb3e6c49cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change perspective across a face neighbor situation.  <br /></td></tr>
<tr class="separator:a700bfa963b6790ee4f7c0fb3e6c49cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab982ac15cb017d497f19a02b9507084c" id="r_ab982ac15cb017d497f19a02b9507084c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ab982ac15cb017d497f19a02b9507084c">fclaw_patch_face_transformation</a> (int dim, int faceno, int rfaceno, int ftransform[])</td></tr>
<tr class="memdesc:ab982ac15cb017d497f19a02b9507084c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an array with the axis combination of a face neighbor transform.  <br /></td></tr>
<tr class="separator:ab982ac15cb017d497f19a02b9507084c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635fbdf7339e70de56b6cd0704c2dc8c" id="r_a635fbdf7339e70de56b6cd0704c2dc8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a635fbdf7339e70de56b6cd0704c2dc8c">fclaw_patch_face_transformation_block</a> (int dim, int ftransform[], int sameblock)</td></tr>
<tr class="memdesc:a635fbdf7339e70de56b6cd0704c2dc8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an existing face transformation depending on intra-block usage.  <br /></td></tr>
<tr class="separator:a635fbdf7339e70de56b6cd0704c2dc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1026a42408ecf886234ac5e16851c262" id="r_a1026a42408ecf886234ac5e16851c262"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a1026a42408ecf886234ac5e16851c262">fclaw_patch_face_transformation_intra</a> (int dim, int ftransform[])</td></tr>
<tr class="memdesc:a1026a42408ecf886234ac5e16851c262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an array with the axis combination of a face neighbor transformation that operates on two patches in the same block (the trivial case).  <br /></td></tr>
<tr class="separator:a1026a42408ecf886234ac5e16851c262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754fc77761409f3e35e48fe82e800cf6" id="r_a754fc77761409f3e35e48fe82e800cf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a754fc77761409f3e35e48fe82e800cf6">fclaw_patch_face_transformation_valid</a> (int dim, const int ftransform[])</td></tr>
<tr class="memdesc:a754fc77761409f3e35e48fe82e800cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a face transformation is valid.  <br /></td></tr>
<tr class="separator:a754fc77761409f3e35e48fe82e800cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635a8603697dd4300c188fc763fed081" id="r_a635a8603697dd4300c188fc763fed081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a635a8603697dd4300c188fc763fed081">fclaw_patch_2d_transform_face</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, const int ftransform[], int mx, int my, int based, int *i, int *j)</td></tr>
<tr class="memdesc:a635a8603697dd4300c188fc763fed081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a 2D patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:a635a8603697dd4300c188fc763fed081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dabbbda9e63e4a9fdbbd4072a39318" id="r_a19dabbbda9e63e4a9fdbbd4072a39318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a19dabbbda9e63e4a9fdbbd4072a39318">fclaw_patch_2d_transform_face2</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, const int ftransform[], int mx, int my, int based, int i[], int j[])</td></tr>
<tr class="memdesc:a19dabbbda9e63e4a9fdbbd4072a39318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a 2D patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:a19dabbbda9e63e4a9fdbbd4072a39318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42531cfc375834011530ac88ca5dab3f" id="r_a42531cfc375834011530ac88ca5dab3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a42531cfc375834011530ac88ca5dab3f">fclaw_patch_3d_transform_face</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, const int ftransform[], int mx, int my, int mz, int based, int *i, int *j, int *k)</td></tr>
<tr class="memdesc:a42531cfc375834011530ac88ca5dab3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a 3D patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:a42531cfc375834011530ac88ca5dab3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250392e5bbdaa9d98fa988c5ad967812" id="r_a250392e5bbdaa9d98fa988c5ad967812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a250392e5bbdaa9d98fa988c5ad967812">fclaw_patch_3d_transform_face2</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, const int ftransform[], int mx, int my, int mz, int based, int i[], int j[], int k[])</td></tr>
<tr class="memdesc:a250392e5bbdaa9d98fa988c5ad967812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a 3D patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:a250392e5bbdaa9d98fa988c5ad967812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b67f29884b3f02a679cee908234a08a" id="r_a5b67f29884b3f02a679cee908234a08a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a5b67f29884b3f02a679cee908234a08a">fclaw_patch_edge_neighbors</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int blockno, int patchno, int edgeno, int *rproc, int *rblockno, int *rpatchno, int *redge, <a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a> *neighbor_size)</td></tr>
<tr class="memdesc:a5b67f29884b3f02a679cee908234a08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine neighbor patch(es) and orientation across a given edge.  <br /></td></tr>
<tr class="separator:a5b67f29884b3f02a679cee908234a08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad371f0ece87c419573c2e9fd03245899" id="r_ad371f0ece87c419573c2e9fd03245899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ad371f0ece87c419573c2e9fd03245899">fclaw_patch_edge_swap</a> (int *edgeno, int *redgeno)</td></tr>
<tr class="memdesc:ad371f0ece87c419573c2e9fd03245899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change perspective across an edge neighbor situation.  <br /></td></tr>
<tr class="separator:ad371f0ece87c419573c2e9fd03245899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3a7787025d30fa93a33c0ad99816b1" id="r_a2c3a7787025d30fa93a33c0ad99816b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a2c3a7787025d30fa93a33c0ad99816b1">fclaw_patch_3d_transform_edge</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, int iedge, int is_block_boundary, int mx, int my, int mz, int based, int *i, int *j, int *k)</td></tr>
<tr class="memdesc:a2c3a7787025d30fa93a33c0ad99816b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:a2c3a7787025d30fa93a33c0ad99816b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43df56bad529b6d188563aad66bcfce" id="r_ad43df56bad529b6d188563aad66bcfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ad43df56bad529b6d188563aad66bcfce">fclaw_patch_3d_transform_edge2</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, int iedge, int is_block_boundary, int mx, int my, int mz, int based, int i[], int j[], int k[])</td></tr>
<tr class="memdesc:ad43df56bad529b6d188563aad66bcfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:ad43df56bad529b6d188563aad66bcfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6fbb5af2ba269f809b5a34efc0a6ef" id="r_a3b6fbb5af2ba269f809b5a34efc0a6ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a3b6fbb5af2ba269f809b5a34efc0a6ef">fclaw_patch_corner_neighbors</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int blockno, int patchno, int cornerno, int *rproc, int *rblockno, int *rpatchno, int *rcorner, <a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a> *neighbor_size)</td></tr>
<tr class="memdesc:a3b6fbb5af2ba269f809b5a34efc0a6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine neighbor patch(es) and orientation across a given corner.  <br /></td></tr>
<tr class="separator:a3b6fbb5af2ba269f809b5a34efc0a6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efc0e82ff160561211f8329a3207026" id="r_a1efc0e82ff160561211f8329a3207026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a1efc0e82ff160561211f8329a3207026">fclaw_patch_corner_swap</a> (int dim, int *cornerno, int *rcornerno)</td></tr>
<tr class="memdesc:a1efc0e82ff160561211f8329a3207026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change perspective across a corner neighbor situation.  <br /></td></tr>
<tr class="separator:a1efc0e82ff160561211f8329a3207026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcefcd4d7fad3c9eb4609786484e113" id="r_a5bcefcd4d7fad3c9eb4609786484e113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a5bcefcd4d7fad3c9eb4609786484e113">fclaw_patch_2d_transform_corner</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, int icorner, int is_block_boundary, int mx, int my, int based, int *i, int *j)</td></tr>
<tr class="memdesc:a5bcefcd4d7fad3c9eb4609786484e113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a 2D patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:a5bcefcd4d7fad3c9eb4609786484e113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf875c963d6488200639046f85c4b474" id="r_adf875c963d6488200639046f85c4b474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#adf875c963d6488200639046f85c4b474">fclaw_patch_2d_transform_corner2</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, int icorner, int is_block_boundary, int mx, int my, int based, int i[], int j[])</td></tr>
<tr class="memdesc:adf875c963d6488200639046f85c4b474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a 2D patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:adf875c963d6488200639046f85c4b474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841123fa198fb6ef07f30265733e4f0f" id="r_a841123fa198fb6ef07f30265733e4f0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a841123fa198fb6ef07f30265733e4f0f">fclaw_patch_3d_transform_corner</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, int icorner, int is_block_boundary, int mx, int my, int mz, int based, int *i, int *j, int *k)</td></tr>
<tr class="memdesc:a841123fa198fb6ef07f30265733e4f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a 3D patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:a841123fa198fb6ef07f30265733e4f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a057e8ca7f6f7db9ca0b980a91d254" id="r_a19a057e8ca7f6f7db9ca0b980a91d254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a19a057e8ca7f6f7db9ca0b980a91d254">fclaw_patch_3d_transform_corner2</a> (<a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *ipatch, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *opatch, int icorner, int is_block_boundary, int mx, int my, int mz, int based, int i[], int j[], int k[])</td></tr>
<tr class="memdesc:a19a057e8ca7f6f7db9ca0b980a91d254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a 3D patch coordinate into a neighbor patch's coordinate system.  <br /></td></tr>
<tr class="separator:a19a057e8ca7f6f7db9ca0b980a91d254"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Data Types</h2></td></tr>
<tr class="memitem:a696527697b4c7761e15241110ccc5b00" id="r_a696527697b4c7761e15241110ccc5b00"><td class="memItemLeft" align="right" valign="top"><a id="a696527697b4c7761e15241110ccc5b00" name="a696527697b4c7761e15241110ccc5b00"></a>
typedef struct fclaw_domain_persist&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_persist_t</b></td></tr>
<tr class="memdesc:a696527697b4c7761e15241110ccc5b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="structfclaw__domain.html" title="The domain structure is a collection of blocks.">fclaw_domain</a>. <br /></td></tr>
<tr class="separator:a696527697b4c7761e15241110ccc5b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345fbab290457176694917260185b95a" id="r_a345fbab290457176694917260185b95a"><td class="memItemLeft" align="right" valign="top"><a id="a345fbab290457176694917260185b95a" name="a345fbab290457176694917260185b95a"></a>
typedef struct <a class="el" href="structfclaw__domain.html">fclaw_domain</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_t</b></td></tr>
<tr class="memdesc:a345fbab290457176694917260185b95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="structfclaw__domain.html" title="The domain structure is a collection of blocks.">fclaw_domain</a>. <br /></td></tr>
<tr class="separator:a345fbab290457176694917260185b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd510bfa3e3ef1eaec1f956b91599a09" id="r_afd510bfa3e3ef1eaec1f956b91599a09"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfclaw__block.html">fclaw_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#afd510bfa3e3ef1eaec1f956b91599a09">fclaw_block_t</a></td></tr>
<tr class="memdesc:afd510bfa3e3ef1eaec1f956b91599a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="structfclaw__block.html" title="Data Structure for a block.">fclaw_block</a>.  <br /></td></tr>
<tr class="separator:afd510bfa3e3ef1eaec1f956b91599a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11426617a538045942e453095717e18" id="r_ab11426617a538045942e453095717e18"><td class="memItemLeft" align="right" valign="top"><a id="ab11426617a538045942e453095717e18" name="ab11426617a538045942e453095717e18"></a>
typedef struct <a class="el" href="structfclaw__patch.html">fclaw_patch</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_patch_t</b></td></tr>
<tr class="memdesc:ab11426617a538045942e453095717e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="structfclaw__patch.html" title="The metadata structure for a forest leaf, which is a forestclaw patch.">fclaw_patch</a>. <br /></td></tr>
<tr class="separator:ab11426617a538045942e453095717e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844d4ceebb80fc2343f8c81f5524a551" id="r_a844d4ceebb80fc2343f8c81f5524a551"><td class="memItemLeft" align="right" valign="top"><a id="a844d4ceebb80fc2343f8c81f5524a551" name="a844d4ceebb80fc2343f8c81f5524a551"></a>
typedef struct <a class="el" href="structfclaw__domain__exchange.html">fclaw_domain_exchange</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_exchange_t</b></td></tr>
<tr class="memdesc:a844d4ceebb80fc2343f8c81f5524a551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="structfclaw__domain.html" title="The domain structure is a collection of blocks.">fclaw_domain</a>. <br /></td></tr>
<tr class="separator:a844d4ceebb80fc2343f8c81f5524a551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afd3cc4bc6789889635b65316b8a445" id="r_a2afd3cc4bc6789889635b65316b8a445"><td class="memItemLeft" align="right" valign="top"><a id="a2afd3cc4bc6789889635b65316b8a445" name="a2afd3cc4bc6789889635b65316b8a445"></a>
typedef struct fclaw_domain_indirect&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_indirect_t</b></td></tr>
<tr class="memdesc:a2afd3cc4bc6789889635b65316b8a445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="structfclaw__domain.html" title="The domain structure is a collection of blocks.">fclaw_domain</a>. <br /></td></tr>
<tr class="separator:a2afd3cc4bc6789889635b65316b8a445"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Patch Iterators</h2></td></tr>
<tr class="memitem:a5d52aeaa386109279c4369ba79fd06c1" id="r_a5d52aeaa386109279c4369ba79fd06c1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a5d52aeaa386109279c4369ba79fd06c1">fclaw_patch_callback_t</a>) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *user)</td></tr>
<tr class="memdesc:a5d52aeaa386109279c4369ba79fd06c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback prototype for the patch iterators.  <br /></td></tr>
<tr class="separator:a5d52aeaa386109279c4369ba79fd06c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52c0849665fb9fb997a003f6ff3651f" id="r_af52c0849665fb9fb997a003f6ff3651f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#af52c0849665fb9fb997a003f6ff3651f">fclaw_domain_iterate_level</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int level, <a class="el" href="forestclaw_8h.html#a5d52aeaa386109279c4369ba79fd06c1">fclaw_patch_callback_t</a> pcb, void *user)</td></tr>
<tr class="memdesc:af52c0849665fb9fb997a003f6ff3651f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all local patches on a given level.  <br /></td></tr>
<tr class="separator:af52c0849665fb9fb997a003f6ff3651f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc88f4bce607b8b55a0a1543d5c02836" id="r_afc88f4bce607b8b55a0a1543d5c02836"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#afc88f4bce607b8b55a0a1543d5c02836">fclaw_domain_iterate_patches</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#a5d52aeaa386109279c4369ba79fd06c1">fclaw_patch_callback_t</a> pcb, void *user)</td></tr>
<tr class="memdesc:afc88f4bce607b8b55a0a1543d5c02836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all local patches of all levels.  <br /></td></tr>
<tr class="separator:afc88f4bce607b8b55a0a1543d5c02836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde75215a1939919cc7d608d52bb0f52" id="r_adde75215a1939919cc7d608d52bb0f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#adde75215a1939919cc7d608d52bb0f52">fclaw_domain_iterate_families</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#a5d52aeaa386109279c4369ba79fd06c1">fclaw_patch_callback_t</a> pcb, void *user)</td></tr>
<tr class="memdesc:adde75215a1939919cc7d608d52bb0f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all families of local sibling patches.  <br /></td></tr>
<tr class="separator:adde75215a1939919cc7d608d52bb0f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Adaptivity</h2></td></tr>
<tr class="memitem:a991b431aaac14be623074fbf1f42b89c" id="r_a991b431aaac14be623074fbf1f42b89c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a991b431aaac14be623074fbf1f42b89c">fclaw_match_callback_t</a>) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *old_domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *old_patch, <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *new_domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *new_patch, <a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a> newsize, int blockno, int old_patchno, int new_patchno, void *user)</td></tr>
<tr class="memdesc:a991b431aaac14be623074fbf1f42b89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback prototype used in fclaw_domain_iterate_adapted.  <br /></td></tr>
<tr class="separator:a991b431aaac14be623074fbf1f42b89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4d93c7f67935add5b165ee966ccef8" id="r_a3d4d93c7f67935add5b165ee966ccef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a3d4d93c7f67935add5b165ee966ccef8">fclaw_domain_set_refinement</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int smooth_refine, int smooth_level, int coarsen_delay)</td></tr>
<tr class="memdesc:a3d4d93c7f67935add5b165ee966ccef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameters of refinement strategy in a domain.  <br /></td></tr>
<tr class="separator:a3d4d93c7f67935add5b165ee966ccef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2869a24c73fedc55c388bf0f17c7a56" id="r_ab2869a24c73fedc55c388bf0f17c7a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ab2869a24c73fedc55c388bf0f17c7a56">fclaw_domain_set_partitioning</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int partition_for_coarsening, int skip_local, int skip_refined)</td></tr>
<tr class="memdesc:ab2869a24c73fedc55c388bf0f17c7a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameters of partitioning strategy in a domain.  <br /></td></tr>
<tr class="separator:ab2869a24c73fedc55c388bf0f17c7a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1d16846a632d2b0909ea64dc0356bd" id="r_a7c1d16846a632d2b0909ea64dc0356bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a7c1d16846a632d2b0909ea64dc0356bd">fclaw_patch_mark_refine</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int blockno, int patchno)</td></tr>
<tr class="memdesc:a7c1d16846a632d2b0909ea64dc0356bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a patch for refinement.  <br /></td></tr>
<tr class="separator:a7c1d16846a632d2b0909ea64dc0356bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75941e1a4b68d123992b9dfc2ee853f" id="r_ac75941e1a4b68d123992b9dfc2ee853f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ac75941e1a4b68d123992b9dfc2ee853f">fclaw_patch_mark_coarsen</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int blockno, int patchno)</td></tr>
<tr class="memdesc:ac75941e1a4b68d123992b9dfc2ee853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a patch for coarsening.  <br /></td></tr>
<tr class="separator:ac75941e1a4b68d123992b9dfc2ee853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6b97982a7b5cd22c753bd83036e40b" id="r_a2e6b97982a7b5cd22c753bd83036e40b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a2e6b97982a7b5cd22c753bd83036e40b">fclaw_domain_iterate_adapted</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *old_domain, <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *new_domain, <a class="el" href="forestclaw_8h.html#a991b431aaac14be623074fbf1f42b89c">fclaw_match_callback_t</a> mcb, void *user)</td></tr>
<tr class="memdesc:a2e6b97982a7b5cd22c753bd83036e40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the previous and the adapted domain simultaneously.  <br /></td></tr>
<tr class="separator:a2e6b97982a7b5cd22c753bd83036e40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Parititon</h2></td></tr>
<tr class="memitem:a2fbb9d505b211d03a2d7afb75686e0c2" id="r_a2fbb9d505b211d03a2d7afb75686e0c2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a2fbb9d505b211d03a2d7afb75686e0c2">fclaw_transfer_callback_t</a>) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *old_domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *old_patch, <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *new_domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *new_patch, int blockno, int old_patchno, int new_patchno, void *user)</td></tr>
<tr class="memdesc:a2fbb9d505b211d03a2d7afb75686e0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to iterate through the partitions.  <br /></td></tr>
<tr class="separator:a2fbb9d505b211d03a2d7afb75686e0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd767f9c6deb51f898af5ac081569b89" id="r_abd767f9c6deb51f898af5ac081569b89"><td class="memItemLeft" align="right" valign="top"><a id="abd767f9c6deb51f898af5ac081569b89" name="abd767f9c6deb51f898af5ac081569b89"></a>
typedef struct <a class="el" href="fclaw__convenience_8h.html#a5aa3b318e719d6a50f9763a0e23c96a5">fclaw_domain_partition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_partition_t</b></td></tr>
<tr class="memdesc:abd767f9c6deb51f898af5ac081569b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for storing allocated data for partition transfer. <br /></td></tr>
<tr class="separator:abd767f9c6deb51f898af5ac081569b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c3fcff85dda749149751f89f814113" id="r_a99c3fcff85dda749149751f89f814113"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a99c3fcff85dda749149751f89f814113">fclaw_pack_callback_t</a>) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *pack_data_here, void *user)</td></tr>
<tr class="memdesc:a99c3fcff85dda749149751f89f814113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to pack patch data after partitioning.  <br /></td></tr>
<tr class="separator:a99c3fcff85dda749149751f89f814113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c2396044c7f5e931c1ebd38d59338e" id="r_a50c2396044c7f5e931c1ebd38d59338e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a50c2396044c7f5e931c1ebd38d59338e">fclaw_unpack_callback_t</a>) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *unpack_data_from_here, void *user)</td></tr>
<tr class="memdesc:a50c2396044c7f5e931c1ebd38d59338e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to unpack patch data after partitioning.  <br /></td></tr>
<tr class="separator:a50c2396044c7f5e931c1ebd38d59338e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0e3b200277e883a7c2c450fe9349aa" id="r_a3b0e3b200277e883a7c2c450fe9349aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a3b0e3b200277e883a7c2c450fe9349aa">fclaw_domain_allocate_before_partition</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, size_t data_size, void ***patch_data)</td></tr>
<tr class="memdesc:a3b0e3b200277e883a7c2c450fe9349aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate data buffer for parallel transfer of all patches.  <br /></td></tr>
<tr class="separator:a3b0e3b200277e883a7c2c450fe9349aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52367f661365419a606c039019d2436" id="r_ab52367f661365419a606c039019d2436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ab52367f661365419a606c039019d2436">fclaw_domain_retrieve_after_partition</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, void ***patch_data)</td></tr>
<tr class="memdesc:ab52367f661365419a606c039019d2436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data buffer to reflect patch data after partition.  <br /></td></tr>
<tr class="separator:ab52367f661365419a606c039019d2436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ed4537e9b239a20ccd637ec6a21704" id="r_a75ed4537e9b239a20ccd637ec6a21704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a75ed4537e9b239a20ccd637ec6a21704">fclaw_domain_iterate_partitioned</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *old_domain, <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *new_domain, <a class="el" href="forestclaw_8h.html#a2fbb9d505b211d03a2d7afb75686e0c2">fclaw_transfer_callback_t</a> tcb, void *user)</td></tr>
<tr class="memdesc:a75ed4537e9b239a20ccd637ec6a21704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the previous and partitioned domain simultaneously.  <br /></td></tr>
<tr class="separator:a75ed4537e9b239a20ccd637ec6a21704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6387bf37684a9e3fbb132284de842126" id="r_a6387bf37684a9e3fbb132284de842126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw_8h.html#abd767f9c6deb51f898af5ac081569b89">fclaw_domain_partition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a6387bf37684a9e3fbb132284de842126">fclaw_domain_iterate_pack</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, size_t data_size, <a class="el" href="forestclaw_8h.html#a99c3fcff85dda749149751f89f814113">fclaw_pack_callback_t</a> patch_pack, void *user)</td></tr>
<tr class="memdesc:a6387bf37684a9e3fbb132284de842126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous transfer of patch data after partition.  <br /></td></tr>
<tr class="separator:a6387bf37684a9e3fbb132284de842126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa796692fe660f1325a37902761bcfe9" id="r_aaa796692fe660f1325a37902761bcfe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#aaa796692fe660f1325a37902761bcfe9">fclaw_domain_iterate_transfer</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *old_domain, <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *new_domain, <a class="el" href="forestclaw_8h.html#a2fbb9d505b211d03a2d7afb75686e0c2">fclaw_transfer_callback_t</a> patch_transfer, void *user)</td></tr>
<tr class="memdesc:aaa796692fe660f1325a37902761bcfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer data of patches still local after partition.  <br /></td></tr>
<tr class="separator:aaa796692fe660f1325a37902761bcfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ee157658fe1e021901cbfd65ff7e6e" id="r_a01ee157658fe1e021901cbfd65ff7e6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a01ee157658fe1e021901cbfd65ff7e6e">fclaw_domain_iterate_unpack</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#abd767f9c6deb51f898af5ac081569b89">fclaw_domain_partition_t</a> *p, <a class="el" href="forestclaw_8h.html#a50c2396044c7f5e931c1ebd38d59338e">fclaw_unpack_callback_t</a> patch_unpack, void *user)</td></tr>
<tr class="memdesc:a01ee157658fe1e021901cbfd65ff7e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete asynchronous transfer of patch data after partition.  <br /></td></tr>
<tr class="separator:a01ee157658fe1e021901cbfd65ff7e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b309e4469ff0ec420f50a52c0eb2541" id="r_a7b309e4469ff0ec420f50a52c0eb2541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a7b309e4469ff0ec420f50a52c0eb2541">fclaw_domain_partition_free</a> (<a class="el" href="forestclaw_8h.html#abd767f9c6deb51f898af5ac081569b89">fclaw_domain_partition_t</a> *p)</td></tr>
<tr class="memdesc:a7b309e4469ff0ec420f50a52c0eb2541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free buffers used in transfering patch data during partition.  <br /></td></tr>
<tr class="separator:a7b309e4469ff0ec420f50a52c0eb2541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13c2e9dd426be168cc1e6f34d48149d" id="r_aa13c2e9dd426be168cc1e6f34d48149d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#aa13c2e9dd426be168cc1e6f34d48149d">fclaw_domain_free_after_partition</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, void ***patch_data)</td></tr>
<tr class="memdesc:aa13c2e9dd426be168cc1e6f34d48149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free buffers that were used in transfering data during partition.  <br /></td></tr>
<tr class="separator:aa13c2e9dd426be168cc1e6f34d48149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Topological Properties</h2></td></tr>
<tr class="memitem:a4ffe0090c5fbe5c2f285f693405a233e" id="r_a4ffe0090c5fbe5c2f285f693405a233e"><td class="memItemLeft" align="right" valign="top"><a id="a4ffe0090c5fbe5c2f285f693405a233e" name="a4ffe0090c5fbe5c2f285f693405a233e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_dimension</b> (const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a4ffe0090c5fbe5c2f285f693405a233e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the space dimension. <br /></td></tr>
<tr class="separator:a4ffe0090c5fbe5c2f285f693405a233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad307e6da257d113bb3dffe71c75c1e1d" id="r_ad307e6da257d113bb3dffe71c75c1e1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ad307e6da257d113bb3dffe71c75c1e1d">fclaw_domain_num_siblings</a> (const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:ad307e6da257d113bb3dffe71c75c1e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of siblings a node has in a domain.  <br /></td></tr>
<tr class="separator:ad307e6da257d113bb3dffe71c75c1e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89034af43151fc4ae7eafadc434989b5" id="r_a89034af43151fc4ae7eafadc434989b5"><td class="memItemLeft" align="right" valign="top"><a id="a89034af43151fc4ae7eafadc434989b5" name="a89034af43151fc4ae7eafadc434989b5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_num_faces</b> (const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a89034af43151fc4ae7eafadc434989b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of faces of a cube: 4 in 2D, 6 in 3D. <br /></td></tr>
<tr class="separator:a89034af43151fc4ae7eafadc434989b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ed90e798aa25797814d19ddc8791ac" id="r_a18ed90e798aa25797814d19ddc8791ac"><td class="memItemLeft" align="right" valign="top"><a id="a18ed90e798aa25797814d19ddc8791ac" name="a18ed90e798aa25797814d19ddc8791ac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_num_edges</b> (const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a18ed90e798aa25797814d19ddc8791ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of edges of a cube: 0 in 2D, 12 in 3D. <br /></td></tr>
<tr class="separator:a18ed90e798aa25797814d19ddc8791ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6748a266f8586985d8962cd22f70eac" id="r_ae6748a266f8586985d8962cd22f70eac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ae6748a266f8586985d8962cd22f70eac">fclaw_domain_num_corners</a> (const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:ae6748a266f8586985d8962cd22f70eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of corners of a cube: 4 in 2D, 8 in 3D.  <br /></td></tr>
<tr class="separator:ae6748a266f8586985d8962cd22f70eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce44a2c7b7f248af695941f1a407bc2" id="r_a3ce44a2c7b7f248af695941f1a407bc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a3ce44a2c7b7f248af695941f1a407bc2">fclaw_domain_num_face_corners</a> (const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a3ce44a2c7b7f248af695941f1a407bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of corners of a cube face: 2 in 2D, 4 in 3D.  <br /></td></tr>
<tr class="separator:a3ce44a2c7b7f248af695941f1a407bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ef640be14c259163cd179833948126" id="r_a79ef640be14c259163cd179833948126"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a79ef640be14c259163cd179833948126">fclaw_domain_num_orientations</a> (const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a79ef640be14c259163cd179833948126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of possible orientations of a cube face.  <br /></td></tr>
<tr class="separator:a79ef640be14c259163cd179833948126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0bdcf158044a9083a36f5392ca878a" id="r_a1b0bdcf158044a9083a36f5392ca878a"><td class="memItemLeft" align="right" valign="top"><a id="a1b0bdcf158044a9083a36f5392ca878a" name="a1b0bdcf158044a9083a36f5392ca878a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_edge_faces</b> (const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int iedge, int faces[2])</td></tr>
<tr class="memdesc:a1b0bdcf158044a9083a36f5392ca878a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the numbers of faces adjacent ot a cube edge: 0 in 2D, 3 in 3D. <br /></td></tr>
<tr class="separator:a1b0bdcf158044a9083a36f5392ca878a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d913cacbb7d19ed673ea4d80daaee8" id="r_a48d913cacbb7d19ed673ea4d80daaee8"><td class="memItemLeft" align="right" valign="top"><a id="a48d913cacbb7d19ed673ea4d80daaee8" name="a48d913cacbb7d19ed673ea4d80daaee8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_corner_faces</b> (const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, int icorner, int faces[3])</td></tr>
<tr class="memdesc:a48d913cacbb7d19ed673ea4d80daaee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the numbers of faces adjacent to a cube corner: 2 in 2D, 3 in 3D. <br /></td></tr>
<tr class="separator:a48d913cacbb7d19ed673ea4d80daaee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Patch Functions</h2></td></tr>
<tr class="memitem:a9568605c41e3389ecc27f6f2abe837a5" id="r_a9568605c41e3389ecc27f6f2abe837a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a9568605c41e3389ecc27f6f2abe837a5">fclaw_patch_corner_dimension</a> (const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int cornerno)</td></tr>
<tr class="memdesc:a9568605c41e3389ecc27f6f2abe837a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of a corner.  <br /></td></tr>
<tr class="separator:a9568605c41e3389ecc27f6f2abe837a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecae0d4de747bac667f21d8d2834c0f0" id="r_aecae0d4de747bac667f21d8d2834c0f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#aecae0d4de747bac667f21d8d2834c0f0">fclaw_patch_childid</a> (const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch)</td></tr>
<tr class="memdesc:aecae0d4de747bac667f21d8d2834c0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of a patch with respect to its parent in the tree.  <br /></td></tr>
<tr class="separator:aecae0d4de747bac667f21d8d2834c0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e81f3e98a53bfeb638faeae148f8aad" id="r_a7e81f3e98a53bfeb638faeae148f8aad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a7e81f3e98a53bfeb638faeae148f8aad">fclaw_patch_is_first_sibling</a> (const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch)</td></tr>
<tr class="memdesc:a7e81f3e98a53bfeb638faeae148f8aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a patch is the first in a family of four siblings.  <br /></td></tr>
<tr class="separator:a7e81f3e98a53bfeb638faeae148f8aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943da1eeb67c4d6802d8733dfe7cdda2" id="r_a943da1eeb67c4d6802d8733dfe7cdda2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a943da1eeb67c4d6802d8733dfe7cdda2">fclaw_patch_is_ghost</a> (const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch)</td></tr>
<tr class="memdesc:a943da1eeb67c4d6802d8733dfe7cdda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a patch is a parallel ghost patch.  <br /></td></tr>
<tr class="separator:a943da1eeb67c4d6802d8733dfe7cdda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8973008fb6434d4bb0581d6231955f83" id="r_a8973008fb6434d4bb0581d6231955f83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a8973008fb6434d4bb0581d6231955f83">fclaw_patch_get_ghost_block</a> (const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch)</td></tr>
<tr class="memdesc:a8973008fb6434d4bb0581d6231955f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the block number of a ghost patch.  <br /></td></tr>
<tr class="separator:a8973008fb6434d4bb0581d6231955f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Communication</h2></td></tr>
<tr class="memitem:af6bb6450fddb66063205021fe38d373f" id="r_af6bb6450fddb66063205021fe38d373f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#af6bb6450fddb66063205021fe38d373f">fclaw_domain_global_maximum</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, double d)</td></tr>
<tr class="memdesc:af6bb6450fddb66063205021fe38d373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the maximum over all processors of a double value.  <br /></td></tr>
<tr class="separator:af6bb6450fddb66063205021fe38d373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa99e7a6dffc231189c279c4f8ab420" id="r_acfa99e7a6dffc231189c279c4f8ab420"><td class="memItemLeft" align="right" valign="top"><a id="acfa99e7a6dffc231189c279c4f8ab420" name="acfa99e7a6dffc231189c279c4f8ab420"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>fclaw_domain_global_sum</b> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, double d)</td></tr>
<tr class="memdesc:acfa99e7a6dffc231189c279c4f8ab420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the sum over all processors of a double value. <br /></td></tr>
<tr class="separator:acfa99e7a6dffc231189c279c4f8ab420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82f105d1419c99c4f73a33f41150f1" id="r_aca82f105d1419c99c4f73a33f41150f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#aca82f105d1419c99c4f73a33f41150f1">fclaw_domain_barrier</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:aca82f105d1419c99c4f73a33f41150f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize all processes.  <br /></td></tr>
<tr class="separator:aca82f105d1419c99c4f73a33f41150f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c8747ec028223e6675f676afca40af" id="r_a07c8747ec028223e6675f676afca40af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a07c8747ec028223e6675f676afca40af">fclaw_domain_serialization_enter</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a07c8747ec028223e6675f676afca40af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a section of code.  <br /></td></tr>
<tr class="separator:a07c8747ec028223e6675f676afca40af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6427ef85df4ed8892c7db1852a9ec500" id="r_a6427ef85df4ed8892c7db1852a9ec500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a6427ef85df4ed8892c7db1852a9ec500">fclaw_domain_serialization_leave</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a6427ef85df4ed8892c7db1852a9ec500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a section of code.  <br /></td></tr>
<tr class="separator:a6427ef85df4ed8892c7db1852a9ec500"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Exchange</h2></td></tr>
<tr class="memitem:ae248aa8347871b54bb324fc4ec52c1de" id="r_ae248aa8347871b54bb324fc4ec52c1de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ae248aa8347871b54bb324fc4ec52c1de">fclaw_domain_allocate_before_exchange</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, size_t data_size)</td></tr>
<tr class="memdesc:ae248aa8347871b54bb324fc4ec52c1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate buffer to hold the data from off-processor patches.  <br /></td></tr>
<tr class="separator:ae248aa8347871b54bb324fc4ec52c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c83514de38e3204b4e61c4a3e652d7c" id="r_a4c83514de38e3204b4e61c4a3e652d7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a4c83514de38e3204b4e61c4a3e652d7c">fclaw_domain_ghost_exchange</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> *e, int exchange_minlevel, int exchange_maxlevel)</td></tr>
<tr class="memdesc:a4c83514de38e3204b4e61c4a3e652d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange data for parallel ghost neighbors.  <br /></td></tr>
<tr class="separator:a4c83514de38e3204b4e61c4a3e652d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef866285f8895790aea7b671889dc58" id="r_a9ef866285f8895790aea7b671889dc58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a9ef866285f8895790aea7b671889dc58">fclaw_domain_ghost_exchange_begin</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> *e, int exchange_minlevel, int exchange_maxlevel)</td></tr>
<tr class="memdesc:a9ef866285f8895790aea7b671889dc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous exchange of parallel ghost neighbors.  <br /></td></tr>
<tr class="separator:a9ef866285f8895790aea7b671889dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043069836ddde466650ff795b147841f" id="r_a043069836ddde466650ff795b147841f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a043069836ddde466650ff795b147841f">fclaw_domain_ghost_exchange_end</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> *e)</td></tr>
<tr class="memdesc:a043069836ddde466650ff795b147841f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete asynchronous exchange of parallel ghost neighbors.  <br /></td></tr>
<tr class="separator:a043069836ddde466650ff795b147841f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a4e3fbc977a57e21e87e252985125c" id="r_af0a4e3fbc977a57e21e87e252985125c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#af0a4e3fbc977a57e21e87e252985125c">fclaw_domain_free_after_exchange</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> *e)</td></tr>
<tr class="memdesc:af0a4e3fbc977a57e21e87e252985125c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free buffers used in exchanging off-processor data during time stepping.  <br /></td></tr>
<tr class="separator:af0a4e3fbc977a57e21e87e252985125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Indirect Parallel Neighbors</h2></td></tr>
<tr class="memitem:a8c9bf7c91b8f938851b9d8496f4d57b6" id="r_a8c9bf7c91b8f938851b9d8496f4d57b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw_8h.html#a2afd3cc4bc6789889635b65316b8a445">fclaw_domain_indirect_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a8c9bf7c91b8f938851b9d8496f4d57b6">fclaw_domain_indirect_begin</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a8c9bf7c91b8f938851b9d8496f4d57b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin sending messages to determine neighbors of ghost patches.  <br /></td></tr>
<tr class="separator:a8c9bf7c91b8f938851b9d8496f4d57b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42f1ab967a9987cd7daa61288f01f87" id="r_ad42f1ab967a9987cd7daa61288f01f87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#ad42f1ab967a9987cd7daa61288f01f87">fclaw_domain_indirect_end</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#a2afd3cc4bc6789889635b65316b8a445">fclaw_domain_indirect_t</a> *ind)</td></tr>
<tr class="memdesc:ad42f1ab967a9987cd7daa61288f01f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">End sending messages to determine neighbors of ghost patches.  <br /></td></tr>
<tr class="separator:ad42f1ab967a9987cd7daa61288f01f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbde2db12d683318bdfec61d764ee14" id="r_aacbde2db12d683318bdfec61d764ee14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#aacbde2db12d683318bdfec61d764ee14">fclaw_domain_indirect_face_neighbors</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#a2afd3cc4bc6789889635b65316b8a445">fclaw_domain_indirect_t</a> *ind, int ghostno, int faceno, int rproc[], int *rblockno, int rpatchno[], int *rfaceno)</td></tr>
<tr class="memdesc:aacbde2db12d683318bdfec61d764ee14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this analogously to fclaw_domain_face_neighbors.  <br /></td></tr>
<tr class="separator:aacbde2db12d683318bdfec61d764ee14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf48b122af9e49edd6424daa82064eb" id="r_a1cf48b122af9e49edd6424daa82064eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a1cf48b122af9e49edd6424daa82064eb">fclaw_domain_indirect_destroy</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#a2afd3cc4bc6789889635b65316b8a445">fclaw_domain_indirect_t</a> *ind)</td></tr>
<tr class="memdesc:a1cf48b122af9e49edd6424daa82064eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all context data for indirect ghost neighbor patches.  <br /></td></tr>
<tr class="separator:a1cf48b122af9e49edd6424daa82064eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Meta Domains</h2></td></tr>
<tr class="memitem:a41128e9bdff0db4749fd605f2dddaa87" id="r_a41128e9bdff0db4749fd605f2dddaa87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="forestclaw_8h.html#a41128e9bdff0db4749fd605f2dddaa87">fclaw_domain_is_meta</a> (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain)</td></tr>
<tr class="memdesc:a41128e9bdff0db4749fd605f2dddaa87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>domain</em> is an artifical domain.  <br /></td></tr>
<tr class="separator:a41128e9bdff0db4749fd605f2dddaa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main dimension independent ForestClaw structures and routines. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="afd510bfa3e3ef1eaec1f956b91599a09" name="afd510bfa3e3ef1eaec1f956b91599a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd510bfa3e3ef1eaec1f956b91599a09">&#9670;&#160;</a></span>fclaw_block_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfclaw__block.html">fclaw_block</a> <a class="el" href="forestclaw_8h.html#afd510bfa3e3ef1eaec1f956b91599a09">fclaw_block_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for <a class="el" href="structfclaw__block.html" title="Data Structure for a block.">fclaw_block</a>. </p>
<p>Data Structure for a block. </p>

</div>
</div>
<a id="a991b431aaac14be623074fbf1f42b89c" name="a991b431aaac14be623074fbf1f42b89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991b431aaac14be623074fbf1f42b89c">&#9670;&#160;</a></span>fclaw_match_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fclaw_match_callback_t) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *old_domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *old_patch, <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *new_domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *new_patch, <a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a> newsize, int blockno, int old_patchno, int new_patchno, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback prototype used in fclaw_domain_iterate_adapted. </p>
<p>The newsize value informs on refine/coarsen/noop status. If refined (new patch is HALFSIZE), the old patch is old_patch[0] and the new patches are given by new_patch[0] through new_patch[3]. The new_patchno numbers are consecutive as well. If noop (new patch is SAMESIZE), only old_patch[0] and new_patch[0] matter. If coarsened (new patch is DOUBLESIZE), situation is the reverse of refine. We iterate over local patches only. </p>

</div>
</div>
<a id="a99c3fcff85dda749149751f89f814113" name="a99c3fcff85dda749149751f89f814113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c3fcff85dda749149751f89f814113">&#9670;&#160;</a></span>fclaw_pack_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fclaw_pack_callback_t) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *pack_data_here, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to pack patch data after partitioning. </p>
<p>The function <a class="el" href="forestclaw_8h.html#a6387bf37684a9e3fbb132284de842126">fclaw_domain_iterate_pack</a> traverses every local patch in the old partition. If that patch has to be packed for the new partition, it invokes this callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>Domain before partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">patch</td><td>Patch from the domain. Its user data should be packed into <b>pack_data_here</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the current block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pack_data_here</td><td>Address of storage space for the patch's user data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Pointer passed to <a class="el" href="forestclaw_8h.html#a6387bf37684a9e3fbb132284de842126">fclaw_domain_iterate_pack</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d52aeaa386109279c4369ba79fd06c1" name="a5d52aeaa386109279c4369ba79fd06c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d52aeaa386109279c4369ba79fd06c1">&#9670;&#160;</a></span>fclaw_patch_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fclaw_patch_callback_t) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback prototype for the patch iterators. </p>
<p>We iterate over local patches only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>General domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>The local patch currently processed by the iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Block number of processed patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Patch number within block of processed patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Data that was passed into the iterator functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fbb9d505b211d03a2d7afb75686e0c2" name="a2fbb9d505b211d03a2d7afb75686e0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbb9d505b211d03a2d7afb75686e0c2">&#9670;&#160;</a></span>fclaw_transfer_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fclaw_transfer_callback_t) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *old_domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *old_patch, <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *new_domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *new_patch, int blockno, int old_patchno, int new_patchno, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to iterate through the partitions. </p>
<p>We traverse every patch in the new partition. If that patch was already on the local processor before the partition, we identify its memory. We iterate over local patches only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">old_domain</td><td>Domain before partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">old_patch</td><td>If the patch stayed local, this is the pointer in reference to the old domain and partition. Otherwise, this patch pointer is set to NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_domain</td><td>Domain after partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_patch</td><td>Patch in the new domain and partition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the current block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_patchno</td><td>Number of the patch that stayed local wrt. the old domain and partition. Minus one otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_patchno</td><td>Number of the iterated patch wrt. the new domain and partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Pointer passed to <a class="el" href="forestclaw_8h.html#a75ed4537e9b239a20ccd637ec6a21704">fclaw_domain_iterate_partitioned</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50c2396044c7f5e931c1ebd38d59338e" name="a50c2396044c7f5e931c1ebd38d59338e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c2396044c7f5e931c1ebd38d59338e">&#9670;&#160;</a></span>fclaw_unpack_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fclaw_unpack_callback_t) (<a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *domain, <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *patch, int blockno, int patchno, void *unpack_data_from_here, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to unpack patch data after partitioning. </p>
<p>The function <a class="el" href="forestclaw_8h.html#a01ee157658fe1e021901cbfd65ff7e6e">fclaw_domain_iterate_unpack</a> traverses every local patch, that was not local before partitioning and invokes this callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>Domain after partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">patch</td><td>Patch from the domain. Its user data should be unpacked from <b>unpack_data_from_here</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the current block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unpack_data_from_here</td><td>Address of storage space that contains the packed user data of the patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Pointer passed to <a class="el" href="forestclaw_8h.html#a01ee157658fe1e021901cbfd65ff7e6e">fclaw_domain_iterate_unpack</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a465096a89f3d03b85a80a8b749acc367" name="a465096a89f3d03b85a80a8b749acc367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465096a89f3d03b85a80a8b749acc367">&#9670;&#160;</a></span>fclaw_face_neighbor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="forestclaw_8h.html#a465096a89f3d03b85a80a8b749acc367">fclaw_face_neighbor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of face neighbor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a465096a89f3d03b85a80a8b749acc367acf2e88ce9be6e21da957f0a6d042cfb6" name="a465096a89f3d03b85a80a8b749acc367acf2e88ce9be6e21da957f0a6d042cfb6"></a>FCLAW_PATCH_BOUNDARY&#160;</td><td class="fielddoc"><p>Physical boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a465096a89f3d03b85a80a8b749acc367ad4aadb96b5b2ab498858ed98b2c1fdf7" name="a465096a89f3d03b85a80a8b749acc367ad4aadb96b5b2ab498858ed98b2c1fdf7"></a>FCLAW_PATCH_HALFSIZE&#160;</td><td class="fielddoc"><p>Half-size (finer) neighbor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a465096a89f3d03b85a80a8b749acc367acab32f867ecb3a20d50714288a0cf817" name="a465096a89f3d03b85a80a8b749acc367acab32f867ecb3a20d50714288a0cf817"></a>FCLAW_PATCH_SAMESIZE&#160;</td><td class="fielddoc"><p>Same-size neighbor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a465096a89f3d03b85a80a8b749acc367a7c887f8f4b477b61302beb3a48e0ff2c" name="a465096a89f3d03b85a80a8b749acc367a7c887f8f4b477b61302beb3a48e0ff2c"></a>FCLAW_PATCH_DOUBLESIZE&#160;</td><td class="fielddoc"><p>Double-size (coarser) neighbor. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae248aa8347871b54bb324fc4ec52c1de" name="ae248aa8347871b54bb324fc4ec52c1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae248aa8347871b54bb324fc4ec52c1de">&#9670;&#160;</a></span>fclaw_domain_allocate_before_exchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> * fclaw_domain_allocate_before_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate buffer to hold the data from off-processor patches. </p>
<p>Free this by fclaw_domain_free_after_exchange before regridding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain is not modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Number of bytes per patch to exchange. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated data structure. The pointers in patch_data[i] need to be set after this call by forestclaw. </dd></dl>

</div>
</div>
<a id="a3b0e3b200277e883a7c2c450fe9349aa" name="a3b0e3b200277e883a7c2c450fe9349aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0e3b200277e883a7c2c450fe9349aa">&#9670;&#160;</a></span>fclaw_domain_allocate_before_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_allocate_before_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>patch_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate data buffer for parallel transfer of all patches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>The memory lives inside this domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Number of bytes per patch to transfer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">patch_data</td><td>Address of an array of void pointers. Data is allocated by this function. After the call, *patch_data holds one pointer per patch that points to exactly data_size bytes of memory that can be written to by forestclaw. *patch_data must be NULL before the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca82f105d1419c99c4f73a33f41150f1" name="aca82f105d1419c99c4f73a33f41150f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca82f105d1419c99c4f73a33f41150f1">&#9670;&#160;</a></span>fclaw_domain_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize all processes. </p>
<p>Avoid using if at all possible. </p>

</div>
</div>
<a id="af0a4e3fbc977a57e21e87e252985125c" name="af0a4e3fbc977a57e21e87e252985125c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a4e3fbc977a57e21e87e252985125c">&#9670;&#160;</a></span>fclaw_domain_free_after_exchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_free_after_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free buffers used in exchanging off-processor data during time stepping. </p>
<p>This should be done just before regridding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain is not modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Allocated buffers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa13c2e9dd426be168cc1e6f34d48149d" name="aa13c2e9dd426be168cc1e6f34d48149d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13c2e9dd426be168cc1e6f34d48149d">&#9670;&#160;</a></span>fclaw_domain_free_after_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_free_after_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>patch_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free buffers that were used in transfering data during partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>The memory lives inside this domain. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">patch_data</td><td>Address of an array of void pointers to free. *patch_data will be NULL after the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c83514de38e3204b4e61c4a3e652d7c" name="a4c83514de38e3204b4e61c4a3e652d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c83514de38e3204b4e61c4a3e652d7c">&#9670;&#160;</a></span>fclaw_domain_ghost_exchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_ghost_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exchange_minlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exchange_maxlevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange data for parallel ghost neighbors. </p>
<p>This function receives data from parallel neighbor (ghost) patches. It can be called multiple times on the same allocated buffers. We assume that the data size for all patches is the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Used to access forest and ghost metadata. #(sent patches) is domain-&gt;num_exchange_patches. #(received patches) is domain-&gt;num_ghost_patches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Allocated buffers whose e-&gt;patch_data[i] pointers must have been set properly by forestclaw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exchange_minlevel</td><td>The minimum quadrant level that is exchanged. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exchange_maxlevel</td><td>The maximum quadrant level that is exchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ef866285f8895790aea7b671889dc58" name="a9ef866285f8895790aea7b671889dc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef866285f8895790aea7b671889dc58">&#9670;&#160;</a></span>fclaw_domain_ghost_exchange_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_ghost_exchange_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exchange_minlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exchange_maxlevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous exchange of parallel ghost neighbors. </p>
<p>The arguments are the same as for fclaw_domain_ghost_exchange. It must be followed by a call to fclaw_domain_ghost_exchange_end. Between begin and end, neither of <a class="el" href="forestclaw_8h.html#a8c9bf7c91b8f938851b9d8496f4d57b6">fclaw_domain_indirect_begin</a> and _end must be called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>Its ghost_data member must survive and not be written to until the completion of fclaw_domain_ghost_exchange_end. Its patch_data member may already be overwritten after this function returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a043069836ddde466650ff795b147841f" name="a043069836ddde466650ff795b147841f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043069836ddde466650ff795b147841f">&#9670;&#160;</a></span>fclaw_domain_ghost_exchange_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_ghost_exchange_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a844d4ceebb80fc2343f8c81f5524a551">fclaw_domain_exchange_t</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete asynchronous exchange of parallel ghost neighbors. </p>
<p>Must be called at some point after fclaw_domain_ghost_exchange_begin. Between begin and end, neither of <a class="el" href="forestclaw_8h.html#a8c9bf7c91b8f938851b9d8496f4d57b6">fclaw_domain_indirect_begin</a> and _end must be called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>Its ghost_data member must have survived. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6bb6450fddb66063205021fe38d373f" name="af6bb6450fddb66063205021fe38d373f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bb6450fddb66063205021fe38d373f">&#9670;&#160;</a></span>fclaw_domain_global_maximum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fclaw_domain_global_maximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and return the maximum over all processors of a double value. </p>
<p>The minimum can be computed by using this function on the negative value. </p>

</div>
</div>
<a id="a8c9bf7c91b8f938851b9d8496f4d57b6" name="a8c9bf7c91b8f938851b9d8496f4d57b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9bf7c91b8f938851b9d8496f4d57b6">&#9670;&#160;</a></span>fclaw_domain_indirect_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw_8h.html#a2afd3cc4bc6789889635b65316b8a445">fclaw_domain_indirect_t</a> * fclaw_domain_indirect_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin sending messages to determine neighbors of ghost patches. </p>
<p>This call must not be interleaved with any ghost_exchange calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>This domain must remain valid until <a class="el" href="forestclaw_8h.html#a1cf48b122af9e49edd6424daa82064eb">fclaw_domain_indirect_destroy</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A private data structure that will hold the context for indirect ghost neighbors. </dd></dl>

</div>
</div>
<a id="a1cf48b122af9e49edd6424daa82064eb" name="a1cf48b122af9e49edd6424daa82064eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf48b122af9e49edd6424daa82064eb">&#9670;&#160;</a></span>fclaw_domain_indirect_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_indirect_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a2afd3cc4bc6789889635b65316b8a445">fclaw_domain_indirect_t</a> *&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy all context data for indirect ghost neighbor patches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Must be the same domain used in begin and end. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ind</td><td>Memory will be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad42f1ab967a9987cd7daa61288f01f87" name="ad42f1ab967a9987cd7daa61288f01f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42f1ab967a9987cd7daa61288f01f87">&#9670;&#160;</a></span>fclaw_domain_indirect_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_indirect_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a2afd3cc4bc6789889635b65316b8a445">fclaw_domain_indirect_t</a> *&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End sending messages to determine neighbors of ghost patches. </p>
<p>This call must not be interleaved with any ghost_exchange calls. When this function returns, the necessary information is complete and fclaw_domain_indirect_neighbors may be called any number of times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Must be the same domain used in the begin call. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ind</td><td>Must be returned by an earlier call to <a class="el" href="forestclaw_8h.html#a8c9bf7c91b8f938851b9d8496f4d57b6">fclaw_domain_indirect_begin</a> and will be completed with parallel information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacbde2db12d683318bdfec61d764ee14" name="aacbde2db12d683318bdfec61d764ee14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbde2db12d683318bdfec61d764ee14">&#9670;&#160;</a></span>fclaw_domain_indirect_face_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a> fclaw_domain_indirect_face_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a2afd3cc4bc6789889635b65316b8a445">fclaw_domain_indirect_t</a> *&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ghostno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rproc</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rblockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rpatchno</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rfaceno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this analogously to fclaw_domain_face_neighbors. </p>
<p>Return an indirect face neighbor patch: It is defined as a ghost patch that is face neighbor to the calling ghost patch and belongs to a process that is neither the owner of that ghost patch nor our own process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Must be the same domain used in begin and end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ind</td><td>Must have been initialized by <a class="el" href="forestclaw_8h.html#ad42f1ab967a9987cd7daa61288f01f87">fclaw_domain_indirect_end</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ghostno</td><td>Number of the ghost patch whose neighbors we seek. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceno</td><td>Number of the ghost patch's face to look across. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rproc</td><td>Processor number of neighbor patches. Exception 1: If the neighbor is a bigger patch, rproc[1] contains the number of the small patch as one the smaller faces, but only if the neighbor fits the above criteria. Exception 2: For non-indirect patches, set it to -1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rblockno</td><td>The number of the neighbor block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpatchno</td><td>Only for indirect ghost patches, we store the number relative to our ghost patch array. For all other patches, this is -1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faceno</td><td>The face number and orientation of the neighbor(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Only for indirect ghost patches, the size of the neighbor(s). For all others, we set this to fclaw_PATCH_BOUNDARY. </dd></dl>

</div>
</div>
<a id="a41128e9bdff0db4749fd605f2dddaa87" name="a41128e9bdff0db4749fd605f2dddaa87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41128e9bdff0db4749fd605f2dddaa87">&#9670;&#160;</a></span>fclaw_domain_is_meta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_domain_is_meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <em>domain</em> is an artifical domain. </p>
<p>This function can be used in <a class="el" href="fclaw__convenience_8h.html#a17656b16b92d877dbaf9ec5f269643a1">fclaw_interpolate_point_t</a> callbacks to distinguish domains that were created during a partition search (and only contain some meta information) from real domains in a local search. </p>

</div>
</div>
<a id="a2e6b97982a7b5cd22c753bd83036e40b" name="a2e6b97982a7b5cd22c753bd83036e40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6b97982a7b5cd22c753bd83036e40b">&#9670;&#160;</a></span>fclaw_domain_iterate_adapted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_iterate_adapted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>old_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>new_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a991b431aaac14be623074fbf1f42b89c">fclaw_match_callback_t</a>&#160;</td>
          <td class="paramname"><em>mcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the previous and the adapted domain simultaneously. </p>
<p>We iterate over local patches only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">old_domain</td><td>Domain before adaptation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_domain</td><td>Domain after adaptation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mcb</td><td>Callback. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>This pointer is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adde75215a1939919cc7d608d52bb0f52" name="adde75215a1939919cc7d608d52bb0f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde75215a1939919cc7d608d52bb0f52">&#9670;&#160;</a></span>fclaw_domain_iterate_families()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_iterate_families </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a5d52aeaa386109279c4369ba79fd06c1">fclaw_patch_callback_t</a>&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all families of local sibling patches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>General domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcb</td><td>Function called for each family in the domain. Its patch argument points to an array of four valid patches that constitute a family of siblings. Their patchnos are consecutive, blockno is the same. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Data is passed to the pcb callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af52c0849665fb9fb997a003f6ff3651f" name="af52c0849665fb9fb997a003f6ff3651f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52c0849665fb9fb997a003f6ff3651f">&#9670;&#160;</a></span>fclaw_domain_iterate_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_iterate_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a5d52aeaa386109279c4369ba79fd06c1">fclaw_patch_callback_t</a>&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all local patches on a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>General domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level to iterate. Ignore patches of other levels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcb</td><td>Function called for each patch of matching level. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Data is passed to the pcb callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6387bf37684a9e3fbb132284de842126" name="a6387bf37684a9e3fbb132284de842126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6387bf37684a9e3fbb132284de842126">&#9670;&#160;</a></span>fclaw_domain_iterate_pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw_8h.html#abd767f9c6deb51f898af5ac081569b89">fclaw_domain_partition_t</a> * fclaw_domain_iterate_pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a99c3fcff85dda749149751f89f814113">fclaw_pack_callback_t</a>&#160;</td>
          <td class="paramname"><em>patch_pack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous transfer of patch data after partition. </p>
<p>This function iterates over the local patches of old partition and determines patches that have to be packed by use of <b>patch_pack</b> based on the options skip_local, skip_refined and partition_for_coarsening (see <a class="el" href="forestclaw_8h.html#ab2869a24c73fedc55c388bf0f17c7a56">fclaw_domain_set_partitioning</a>). Then, the patches are packed and sent. This function must be followed by a call to <a class="el" href="forestclaw_8h.html#a01ee157658fe1e021901cbfd65ff7e6e">fclaw_domain_iterate_unpack</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>The domain before partitioning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>The number of bytes of user data that has to be packed and send per patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patch_pack</td><td>Callback function to pack patch user data into a provided storage address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>This pointer is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated and initialized structure containing internal information for patch data transfer. </dd></dl>

</div>
</div>
<a id="a75ed4537e9b239a20ccd637ec6a21704" name="a75ed4537e9b239a20ccd637ec6a21704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ed4537e9b239a20ccd637ec6a21704">&#9670;&#160;</a></span>fclaw_domain_iterate_partitioned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_iterate_partitioned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>old_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>new_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a2fbb9d505b211d03a2d7afb75686e0c2">fclaw_transfer_callback_t</a>&#160;</td>
          <td class="paramname"><em>tcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the previous and partitioned domain simultaneously. </p>
<p>We iterate over local patches only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">old_domain</td><td>Domain before partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_domain</td><td>Domain after partition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcb</td><td>Callback. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>This pointer is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc88f4bce607b8b55a0a1543d5c02836" name="afc88f4bce607b8b55a0a1543d5c02836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc88f4bce607b8b55a0a1543d5c02836">&#9670;&#160;</a></span>fclaw_domain_iterate_patches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_iterate_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a5d52aeaa386109279c4369ba79fd06c1">fclaw_patch_callback_t</a>&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all local patches of all levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>General domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcb</td><td>Function called for each patch in the domain. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">user</td><td>Data is passed to the pcb callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa796692fe660f1325a37902761bcfe9" name="aaa796692fe660f1325a37902761bcfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa796692fe660f1325a37902761bcfe9">&#9670;&#160;</a></span>fclaw_domain_iterate_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_iterate_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>old_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>new_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a2fbb9d505b211d03a2d7afb75686e0c2">fclaw_transfer_callback_t</a>&#160;</td>
          <td class="paramname"><em>patch_transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer data of patches still local after partition. </p>
<p>This function iterates over all pairs of local patches in the domain before and after partitioning and invokes the transfer of their user-data via <b>patch_transfer</b>. It may be called before, between or after <a class="el" href="forestclaw_8h.html#a6387bf37684a9e3fbb132284de842126">fclaw_domain_iterate_pack</a> and <a class="el" href="forestclaw_8h.html#a01ee157658fe1e021901cbfd65ff7e6e">fclaw_domain_iterate_unpack</a>. It is recommended to call it between packing and unpacking, to overlap communication with computation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">old_domain</td><td>The domain before partitioning. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_domain</td><td>The domain after partitioning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patch_transfer</td><td>Callback function to transfer user data between local old and new patch, e.g. by a copy or reassignment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>This pointer is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01ee157658fe1e021901cbfd65ff7e6e" name="a01ee157658fe1e021901cbfd65ff7e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ee157658fe1e021901cbfd65ff7e6e">&#9670;&#160;</a></span>fclaw_domain_iterate_unpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_iterate_unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#abd767f9c6deb51f898af5ac081569b89">fclaw_domain_partition_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a50c2396044c7f5e931c1ebd38d59338e">fclaw_unpack_callback_t</a>&#160;</td>
          <td class="paramname"><em>patch_unpack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete asynchronous transfer of patch data after partition. </p>
<p>This function iterates over all local patches of the new partition and determines patches that have to be unpacked by use of <b>patch_unpack</b> based on the options skip_local, skip_refined and partition_for_coarsening (see <a class="el" href="forestclaw_8h.html#ab2869a24c73fedc55c388bf0f17c7a56">fclaw_domain_set_partitioning</a>). It must be preceded by a call to <a class="el" href="forestclaw_8h.html#a01ee157658fe1e021901cbfd65ff7e6e">fclaw_domain_iterate_unpack</a> and provided with the corresponding <a class="el" href="forestclaw_8h.html#abd767f9c6deb51f898af5ac081569b89">fclaw_domain_partition_t</a> <b>p</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>The domain after partitioning. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>Structure containing internal information for the patch data transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patch_pack</td><td>Callback function to unpack patch user data from a provided storage address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>This pointer is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated and initialized structure containing internal information for patch data transfer. </dd></dl>

</div>
</div>
<a id="ae6748a266f8586985d8962cd22f70eac" name="ae6748a266f8586985d8962cd22f70eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6748a266f8586985d8962cd22f70eac">&#9670;&#160;</a></span>fclaw_domain_num_corners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_domain_num_corners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of corners of a cube: 4 in 2D, 8 in 3D. </p>
<p>This is the same as the number of siblings in a refined tree. </p>

</div>
</div>
<a id="a3ce44a2c7b7f248af695941f1a407bc2" name="a3ce44a2c7b7f248af695941f1a407bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce44a2c7b7f248af695941f1a407bc2">&#9670;&#160;</a></span>fclaw_domain_num_face_corners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_domain_num_face_corners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of corners of a cube face: 2 in 2D, 4 in 3D. </p>
<p>This is the same as the number of refined (smaller) face neighbors. </p>

</div>
</div>
<a id="a79ef640be14c259163cd179833948126" name="a79ef640be14c259163cd179833948126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ef640be14c259163cd179833948126">&#9670;&#160;</a></span>fclaw_domain_num_orientations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_domain_num_orientations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of possible orientations of a cube face. </p>
<p>This is mostly used for internal encodings. </p>

</div>
</div>
<a id="ad307e6da257d113bb3dffe71c75c1e1d" name="ad307e6da257d113bb3dffe71c75c1e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad307e6da257d113bb3dffe71c75c1e1d">&#9670;&#160;</a></span>fclaw_domain_num_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_domain_num_siblings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of siblings a node has in a domain. </p>
<p>4 in 2d, 8 in 3d. </p>

</div>
</div>
<a id="a7b309e4469ff0ec420f50a52c0eb2541" name="a7b309e4469ff0ec420f50a52c0eb2541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b309e4469ff0ec420f50a52c0eb2541">&#9670;&#160;</a></span>fclaw_domain_partition_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_partition_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#abd767f9c6deb51f898af5ac081569b89">fclaw_domain_partition_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free buffers used in transfering patch data during partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Structure containing internal information for patch data transfer. Will be deallocated during this function call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab52367f661365419a606c039019d2436" name="ab52367f661365419a606c039019d2436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52367f661365419a606c039019d2436">&#9670;&#160;</a></span>fclaw_domain_retrieve_after_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_retrieve_after_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>patch_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data buffer to reflect patch data after partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>The memory lives inside this domain. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">patch_data</td><td>Address of an array of void pointers. Data is reallocated by this function. After the call, *patch_data holds one pointer per patch that points to exactly data_size bytes of memory that can be read from by forestclaw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07c8747ec028223e6675f676afca40af" name="a07c8747ec028223e6675f676afca40af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c8747ec028223e6675f676afca40af">&#9670;&#160;</a></span>fclaw_domain_serialization_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_serialization_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a section of code. </p>
<p>THIS IS NOT SCALABLE. WILL BE HORRIBLY SLOW FOR LARGE NUMBERS OF PROCESSORS. A processor returns from this function only after all lower-numbered processors have called fclaw_domain_serialization_leave. No collective communication routines must be called between the calls to this function and fclaw_domain_serialization_leave. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain is not modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6427ef85df4ed8892c7db1852a9ec500" name="a6427ef85df4ed8892c7db1852a9ec500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6427ef85df4ed8892c7db1852a9ec500">&#9670;&#160;</a></span>fclaw_domain_serialization_leave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_serialization_leave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a section of code. </p>
<p>THIS IS NOT SCALABLE. WILL BE HORRIBLY SLOW FOR LARGE NUMBERS OF PROCESSORS. A processor must call this function to allow all higher-numbered processors to return from fclaw_domain_serialization_enter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The domain is not modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2869a24c73fedc55c388bf0f17c7a56" name="ab2869a24c73fedc55c388bf0f17c7a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2869a24c73fedc55c388bf0f17c7a56">&#9670;&#160;</a></span>fclaw_domain_set_partitioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_set_partitioning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partition_for_coarsening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip_local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip_refined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set parameters of partitioning strategy in a domain. </p>
<p>This function only needs to be called once, and only for the first domain created in the program. The values of the parameters are automatically transferred on adaptation and partitioning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>This domain's partitioning strategy is set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partition_for_coarsening</td><td>Boolean: If true, all future partitions of the domain allow one level of coarsening. Suggested default: 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_local</td><td>Boolean: If true, the patch data of patches that stay local are not packed during partitioning. Suggested default: 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_refined</td><td>Boolean: If true, the patch data of patches that were refined during the most recent call to <a class="el" href="fclaw__convenience_8h.html#a02d06433d0f62c4103e631e94abc8cf8">fclaw_domain_adapt</a> is only packed for the patches with child id 0 in fclaw_domain_iterate_pack. The unpack callback in fclaw_domain_iterate_unpack will be invoked for all children of a recently refined patch. The provided data will be the data packed by the patch with child id 0. For this partitioning method to work as desired, skip_refined has to be set <b>before</b> the most recent call to <a class="el" href="fclaw__convenience_8h.html#a02d06433d0f62c4103e631e94abc8cf8">fclaw_domain_adapt</a> . Suggested default: 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d4d93c7f67935add5b165ee966ccef8" name="a3d4d93c7f67935add5b165ee966ccef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4d93c7f67935add5b165ee966ccef8">&#9670;&#160;</a></span>fclaw_domain_set_refinement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_domain_set_refinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smooth_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smooth_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarsen_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set parameters of refinement strategy in a domain. </p>
<p>This function only needs to be called once, and only for the first domain created in the program. The values of the parameters are automatically transferred on adaptation and partitioning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">domain</td><td>This domain's refinement strategy is set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smooth_refine</td><td>Activate or deactivete refinement smoothing. A newly created domain has this set to false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smooth_level</td><td>If <b>smooth_refine</b> is true, denotes the lowest level that activates the smoothing. Use zero for smoothing across all levels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarsen_delay</td><td>Non-negative number to set the delay for coarsening after a patch has been last refined. This number is a global threshold that is compared against each patch's individual counter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bcefcd4d7fad3c9eb4609786484e113" name="a5bcefcd4d7fad3c9eb4609786484e113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcefcd4d7fad3c9eb4609786484e113">&#9670;&#160;</a></span>fclaw_patch_2d_transform_corner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_2d_transform_corner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a 2D patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the two patches are of the SAME size and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. It is ILLEGAL to call this function for patches from face-neighboring blocks. Use <a class="el" href="forestclaw2d_8h.html#ab3fd383aa98dc00a4534e6989f418f1d">fclaw2d_patch_transform_face</a> for such patches instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">icorner</td><td>Corner number of this patch to transform across. This function assumes ocorner == icorner ^ 3, so ocorner is the opposite corner of icorner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>Integer coordinate along x-axis in <em>based</em> .. <em>mx</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>Integer coordinate along y-axis in <em>based</em> .. <em>my</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf875c963d6488200639046f85c4b474" name="adf875c963d6488200639046f85c4b474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf875c963d6488200639046f85c4b474">&#9670;&#160;</a></span>fclaw_patch_2d_transform_corner2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_2d_transform_corner2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a 2D patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the neighbor patch is smaller (HALF size) and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. It is ILLEGAL to call this function for patches from face-neighboring blocks. Use <a class="el" href="forestclaw2d_8h.html#a784d9e362ef21afad1c1c7d24496c844">fclaw2d_patch_transform_face2</a> for such patches instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">icorner</td><td>Corner number of this patch to transform across. This function assumes ocorner == icorner ^ 3, so ocorner is the opposite corner of icorner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>FOUR (4) integer coordinates along x-axis in <em>based</em> .. <em>mx</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>FOUR (4) integer coordinates along y-axis in <em>based</em> .. <em>my</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a635a8603697dd4300c188fc763fed081" name="a635a8603697dd4300c188fc763fed081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635a8603697dd4300c188fc763fed081">&#9670;&#160;</a></span>fclaw_patch_2d_transform_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_2d_transform_face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ftransform</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a 2D patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the two patches are of the SAME size. If the neighbor patch is in the same block we must set (ftransform[8] &amp; 4). Else we have an input patch in one block and on output patch across a face. It is LEGAL to call this function for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ftransform</td><td>It must have room for NINE (9) integers and be computed by <em>fclaw_patch_face_transformation</em>. If <em>ipatch</em> and <em>opatch</em> are in the same block, we require <em>ftransform</em>[8] |= 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. The number of cells must match according to the face transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>Integer coordinate along x-axis in <em>based</em> .. <em>mx</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>Integer coordinate along y-axis in <em>based</em> .. <em>my</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19dabbbda9e63e4a9fdbbd4072a39318" name="a19dabbbda9e63e4a9fdbbd4072a39318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dabbbda9e63e4a9fdbbd4072a39318">&#9670;&#160;</a></span>fclaw_patch_2d_transform_face2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_2d_transform_face2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ftransform</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a 2D patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the neighbor patch is smaller (HALF size). If the neighbor patch is in the same block we must set (ftransform[8] &amp; 4). Else we have an input patch in one block and on output patch across a face. It is LEGAL to call this function for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ftransform</td><td>It must have room for NINE (9) integers and be computed by <em>fclaw_patch_face_transformation</em>. If <em>ipatch</em> and <em>opatch</em> are in the same block, we require <em>ftransform</em>[8] |= 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. The number of cells must match according to the face transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>FOUR (4) integer coordinates along x-axis in <em>based</em> .. <em>mx</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>FOUR (4) integer coordinates along y-axis in <em>based</em> .. <em>my</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a841123fa198fb6ef07f30265733e4f0f" name="a841123fa198fb6ef07f30265733e4f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841123fa198fb6ef07f30265733e4f0f">&#9670;&#160;</a></span>fclaw_patch_3d_transform_corner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_3d_transform_corner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a 3D patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the two patches are of the SAME size and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">icorner</td><td>Corner number of this patch to transform across. This function assumes ocorner == icorner ^ 7, so ocorner is the opposite corner of icorner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>Integer coordinate along x-axis in <em>based</em> .. <em>mx</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>Integer coordinate along y-axis in <em>based</em> .. <em>my</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Integer coordinate along z-axis in <em>based</em> .. <em>mz</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19a057e8ca7f6f7db9ca0b980a91d254" name="a19a057e8ca7f6f7db9ca0b980a91d254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a057e8ca7f6f7db9ca0b980a91d254">&#9670;&#160;</a></span>fclaw_patch_3d_transform_corner2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_3d_transform_corner2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>icorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a 3D patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the neighbor patch is smaller (HALF size) and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. It is ILLEGAL to call this function for patches from face- or edge-neighboring blocks. Use <a class="el" href="forestclaw3d_8h.html#a5ca37a35d7bb36f0162d089a8c2caa86">fclaw3d_patch_transform_face2</a> or <a class="el" href="forestclaw_8h.html#ad43df56bad529b6d188563aad66bcfce">fclaw_patch_3d_transform_edge2</a> for such patches instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">icorner</td><td>Corner number of this patch to transform across. This function assumes ocorner == icorner ^ 7, so ocorner is the opposite corner of icorner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>EIGHT (8) integer coordinates along x-axis in <em>based</em> .. <em>mx</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>my</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>mz</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3a7787025d30fa93a33c0ad99816b1" name="a2c3a7787025d30fa93a33c0ad99816b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3a7787025d30fa93a33c0ad99816b1">&#9670;&#160;</a></span>fclaw_patch_3d_transform_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_3d_transform_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iedge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the two patches are of the SAME size and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. It is ILLEGAL to call this function for patches from face-neighboring blocks. Use <a class="el" href="forestclaw_8h.html#a42531cfc375834011530ac88ca5dab3f">fclaw_patch_3d_transform_face</a> for such patches instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iedge</td><td>Edge number of this patch to transform across. This function assumes oedge == iedge ^ 3, so oedge is the edge opposite of iedge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>Integer coordinate along x-axis in <em>based</em> .. <em>mx</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>Integer coordinate along y-axis in <em>based</em> .. <em>my</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Integer coordinate along z-axis in <em>based</em> .. <em>mz</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43df56bad529b6d188563aad66bcfce" name="ad43df56bad529b6d188563aad66bcfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43df56bad529b6d188563aad66bcfce">&#9670;&#160;</a></span>fclaw_patch_3d_transform_edge2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_3d_transform_edge2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iedge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_block_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the neighbor patch is smaller (HALF size) and that the patches lie in coordinate systems with the same orientation. It is LEGAL to call this function for both local and ghost patches. It is ILLEGAL to call this function for patches from face-neighboring blocks. Use <a class="el" href="forestclaw_8h.html#a42531cfc375834011530ac88ca5dab3f">fclaw_patch_3d_transform_face</a> for such patches instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iedge</td><td>Edge number of this patch to transform across. This function assumes oedge == iedge ^ 3, so oedge is the edge opposite of iedge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_block_boundary</td><td>Set to true for a block edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>EIGHT (8) integer coordinates along x-axis in <em>based</em> .. <em>mx</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>my</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>mz</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42531cfc375834011530ac88ca5dab3f" name="a42531cfc375834011530ac88ca5dab3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42531cfc375834011530ac88ca5dab3f">&#9670;&#160;</a></span>fclaw_patch_3d_transform_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_3d_transform_face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ftransform</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a 3D patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the two patches are of the SAME size. If the neighbor patch is in the same block we must set (ftransform[8] &amp; 4). Else we have an input patch in one block and on output patch across a face. It is LEGAL to call this function for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ftransform</td><td>It must have room for NINE (9) integers and be computed by <em>fclaw3d_patch_face_transformation</em>. If <em>ipatch</em> and <em>opatch</em> are in the same block, we require <em>ftransform</em>[8] |= 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. The number of cells must match according to the face transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>Integer coordinate along x-axis in <em>based</em> .. <em>mx</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>Integer coordinate along y-axis in <em>based</em> .. <em>my</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>Integer coordinate along z-axis in <em>based</em> .. <em>mz</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a250392e5bbdaa9d98fa988c5ad967812" name="a250392e5bbdaa9d98fa988c5ad967812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250392e5bbdaa9d98fa988c5ad967812">&#9670;&#160;</a></span>fclaw_patch_3d_transform_face2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_3d_transform_face2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>ipatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>opatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ftransform</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a 3D patch coordinate into a neighbor patch's coordinate system. </p>
<p>This function assumes that the neighbor patch is smaller (HALF size). If the neighbor patch is in the same block we must set (ftransform[8] &amp; 4). Else we have an input patch in one block and on output patch across a face. It is LEGAL to call this function for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipatch</td><td>The patch that the input coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opatch</td><td>The patch that the output coordinates are relative to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ftransform</td><td>It must have room for NINE (9) integers and be computed by <em>fclaw3d_patch_face_transformation</em>. If <em>ipatch</em> and <em>opatch</em> are in the same block, we require <em>ftransform</em>[8] |= 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mx</td><td>Number of cells along x direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my</td><td>Number of cells along y direction of patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mz</td><td>Number of cells along z direction of patch. The number of cells must match according to the face transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">based</td><td>Indices are 0-based for corners and 1-based for cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>EIGHT (8) integer coordinates along x-axis in <em>based</em> .. <em>mx</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>EIGHT (8) integer coordinates along y-axis in <em>based</em> .. <em>my</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">k</td><td>EIGHT (8) integer coordinates along z-axis in <em>based</em> .. <em>mz</em>. On input, only the first is used. On output, they are relative to the fine patch and stored in order of the children of the coarse patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a799d3ba1ec94b9984173b10318b9721a" name="a799d3ba1ec94b9984173b10318b9721a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799d3ba1ec94b9984173b10318b9721a">&#9670;&#160;</a></span>fclaw_patch_boundary_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_boundary_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>boundaries</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine physical boundary status as 1, or 0 for neighbor patches. </p>
<p>This must ONLY be called for local patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">boundaries</td><td>Domain boundary boolean flags (length 4 for 2D, 6 for 3D). The order is left, right, front, back, bottom, top. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one patch face is on a boundary. </dd></dl>

</div>
</div>
<a id="aecae0d4de747bac667f21d8d2834c0f0" name="aecae0d4de747bac667f21d8d2834c0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecae0d4de747bac667f21d8d2834c0f0">&#9670;&#160;</a></span>fclaw_patch_childid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_childid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of a patch with respect to its parent in the tree. </p>
<p>This function is LEGAL to call for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A patch with properly set member variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child id is a number in 0..3 for 2D or 0..7 for 3D. </dd></dl>

</div>
</div>
<a id="a9568605c41e3389ecc27f6f2abe837a5" name="a9568605c41e3389ecc27f6f2abe837a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9568605c41e3389ecc27f6f2abe837a5">&#9670;&#160;</a></span>fclaw_patch_corner_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_corner_dimension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cornerno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimension of a corner. </p>
<p>This function is LEGAL to call for both local and ghost patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A patch with properly set member variables. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cornerno</td><td>A corner number in 0..3 for 2D or 0..7 for 3D. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the corner is always at a fourfold intersection, 1 if the corner would end up in the middle of a face when there is a coarser neighbor. </dd></dl>

</div>
</div>
<a id="a3b6fbb5af2ba269f809b5a34efc0a6ef" name="a3b6fbb5af2ba269f809b5a34efc0a6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6fbb5af2ba269f809b5a34efc0a6ef">&#9670;&#160;</a></span>fclaw_patch_corner_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_corner_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cornerno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rblockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rpatchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rcorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a> *&#160;</td>
          <td class="paramname"><em>neighbor_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine neighbor patch(es) and orientation across a given corner. </p>
<p>The current version only supports one neighbor, i.e., no true multi-block. A query across a corner in the middle of a longer face returns the boundary. We only return corner neighbors that are not already face neighbors. Inter-tree corners are only returned if the number of meeting corners is exactly four. Five or more are currently not supported. This must ONLY be called for local patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cornerno</td><td>Number of the patch corner: In 2D: 0=bl, 1=br, 2=tl, 3=tr. In 3D: 0=bfl, ..., 7=tbr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rproc</td><td>Processor number of neighbor patch. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rblockno</td><td>Neighbor block number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpatchno</td><td>Neighbor patch number relative to the block. If the neighbor is off-processor, this is not a patch number but in [0, num_ghosts_patches[. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rcorner</td><td>Number of the corner from the other neigbor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighbor_size</td><td>The relative patch size of the neighbor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one corner neighbor exists that is not already a face neighbor. </dd></dl>

</div>
</div>
<a id="a1efc0e82ff160561211f8329a3207026" name="a1efc0e82ff160561211f8329a3207026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efc0e82ff160561211f8329a3207026">&#9670;&#160;</a></span>fclaw_patch_corner_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_corner_swap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>cornerno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rcornerno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change perspective across a corner neighbor situation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension [2, 3]. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cornerno</td><td>On input, valid corner number for a patch. On output, corner number seen from the corner neighbor patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rcornerno</td><td>On input, valid corner number as returned by fclaw_patch_face_neighbors. On output, corner number seen from the corner neighbor patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b67f29884b3f02a679cee908234a08a" name="a5b67f29884b3f02a679cee908234a08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b67f29884b3f02a679cee908234a08a">&#9670;&#160;</a></span>fclaw_patch_edge_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_edge_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rblockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rpatchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>redge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a> *&#160;</td>
          <td class="paramname"><em>neighbor_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine neighbor patch(es) and orientation across a given edge. </p>
<p>The current version only supports one neighbor, i.e., no true multi-block. A query across an edge in the middle of a longer face returns the boundary. We only return edge neighbors that are not already face neighbors. Inter-tree edges are only returned if the number of meeting edges is exactly four. Five or more are currently not supported. This must ONLY be called for local patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeno</td><td>Number of the patch edge: 4 parallel to x axis, then 4 parallel to y axis, then 4 parallel to z. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rproc</td><td>Processor number of neighbor patch. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rblockno</td><td>Neighbor block number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpatchno</td><td>Neighbor patch number of up to 2 neighbors. ` The patch number is relative to its block. If the neighbor is off-processor, this is not a patch number but in [0, num_ghosts_patches[. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">redge</td><td>Number of the edge from the other neighbor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighbor_size</td><td>The relative patch size of the neighbor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one edge neighbor exists that is not already a face neighbor. </dd></dl>

</div>
</div>
<a id="ad371f0ece87c419573c2e9fd03245899" name="ad371f0ece87c419573c2e9fd03245899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad371f0ece87c419573c2e9fd03245899">&#9670;&#160;</a></span>fclaw_patch_edge_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_edge_swap </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>edgeno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>redgeno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change perspective across an edge neighbor situation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">edgeno</td><td>On input, valid edge number for a patch. On output, edge number seen from the edge neighbor patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">redgeno</td><td>On input, valid edge number as returned by fclaw_patch_edge_neighbors. On output, edge number seen from the edge neighbor patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5277bad8d13489cdf30731657c889aab" name="a5277bad8d13489cdf30731657c889aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5277bad8d13489cdf30731657c889aab">&#9670;&#160;</a></span>fclaw_patch_face_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="forestclaw_8h.html#a3af3c3bcbb77754915c4df59af3ad227">fclaw_patch_relation_t</a> fclaw_patch_face_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rproc</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rblockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rpatchno</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rfaceno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine neighbor patch(es) and orientation across a given face. </p>
<p>This must ONLY be called for local patches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceno</td><td>Number of the patch face: left, right, bottom, top. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rproc</td><td>Processor number of neighbor patches (length 2 in 2D, 4 in 3D). <br  />
 Exception: If the neighbor is a bigger patch, rproc[1] contains the number of the small patch as one of the smaller faces. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rblockno</td><td>Neighbor block number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpatchno</td><td>Neighbor patch numbers (length 2 in 2D, 4 in 3D) The patch number is relative to its block. If the neighbor is off-processor, this is not a patch number but in [0, num_ghost_patches[. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rfaceno</td><td>Neighbor face number and orientation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The relative patch size of the face neighbor. </dd></dl>

</div>
</div>
<a id="a700bfa963b6790ee4f7c0fb3e6c49cca" name="a700bfa963b6790ee4f7c0fb3e6c49cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700bfa963b6790ee4f7c0fb3e6c49cca">&#9670;&#160;</a></span>fclaw_patch_face_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_face_swap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>faceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rfaceno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change perspective across a face neighbor situation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension [2, 3]. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">faceno</td><td>On input, valid face number for a patch. On output, valid face number seen from faceno's neighbor patch. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rfaceno</td><td>On input, encoded neighbor face number as returned by fclaw_patch_face_neighbors. On output, encoded neighbor face number seen from faceno's neighbor patch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab982ac15cb017d497f19a02b9507084c" name="ab982ac15cb017d497f19a02b9507084c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab982ac15cb017d497f19a02b9507084c">&#9670;&#160;</a></span>fclaw_patch_face_transformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_face_transformation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rfaceno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ftransform</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill an array with the axis combination of a face neighbor transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension [2, 3]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceno</td><td>The number of the originating face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rfaceno</td><td>In 2D: Encoded as rfaceno = r * 4 + nf, where nf = 0..3 is the neigbbor's connecting face number and r = 0..1 is the relative orientation to the neighbor's face.</td></tr>
  </table>
  </dd>
</dl>
<p>In 3D: Encoded as rfaceno = r * 6 + nf, where nf = 0..3 is the neigbbor's connecting face number and r = 0..1 is the relative orientation to the neighbor's face. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ftransform</td><td>This array holds 9 integers. In 2D: [0,2] The coordinate axis sequence of the origin face, the first referring to the tangential and the second to the normal. A permutation of (0, 1). [3,5] The coordinate axis sequence of the target face. [6,8] Edge reversal flag for tangential axis (boolean); face code in [0, 3] for the normal coordinate q: 0: q' = -q 1: q' = q + 1 2: q' = q - 1 3: q' = 2 - q [8] &amp; 4: Both patches are in the same block, the <em>ftransform</em> contents are ignored. [1,4,7] 0 (unused for compatibility with 3D). <pre class="fragment">        In 3D:
</pre> [0..2] The coordinate axis sequence of the origin face, the first two referring to the tangentials and the third to the normal. A permutation of (0, 1, 2). [3..5] The coordinate axis sequence of the target face. [6..8] Edge reversal flags for tangential axes (boolean); face code in [0, 3] for the normal coordinate q: 0: q' = -q 1: q' = q + 1 2: q' = q - 1 3: q' = 2 - q [8] &amp; 4: Both patches are in the same block, the <em>ftransform</em> contents are ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a635fbdf7339e70de56b6cd0704c2dc8c" name="a635fbdf7339e70de56b6cd0704c2dc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635fbdf7339e70de56b6cd0704c2dc8c">&#9670;&#160;</a></span>fclaw_patch_face_transformation_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_face_transformation_block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ftransform</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sameblock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify an existing face transformation depending on intra-block usage. </p>
<p>This function can be called any number of times on the same transform array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension [2, 3]. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ftransform</td><td>Array of values necessarily created by <a class="el" href="forestclaw_8h.html#ab982ac15cb017d497f19a02b9507084c">fclaw_patch_face_transformation</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sameblock</td><td>Transformation supposed to work in same block? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1026a42408ecf886234ac5e16851c262" name="a1026a42408ecf886234ac5e16851c262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1026a42408ecf886234ac5e16851c262">&#9670;&#160;</a></span>fclaw_patch_face_transformation_intra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_face_transformation_intra </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ftransform</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill an array with the axis combination of a face neighbor transformation that operates on two patches in the same block (the trivial case). </p>
<p>Use when there is no prior call to <a class="el" href="forestclaw_8h.html#ab982ac15cb017d497f19a02b9507084c">fclaw_patch_face_transformation</a>. Don't postprocess the result any further &ndash; it's only useful intra-block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension [2, 3]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ftransform</td><td>Gets initialized to a same-block transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a754fc77761409f3e35e48fe82e800cf6" name="a754fc77761409f3e35e48fe82e800cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754fc77761409f3e35e48fe82e800cf6">&#9670;&#160;</a></span>fclaw_patch_face_transformation_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_face_transformation_valid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ftransform</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether a face transformation is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension [2, 3]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ftransform</td><td>Array of values as created by <a class="el" href="forestclaw_8h.html#ab982ac15cb017d497f19a02b9507084c">fclaw_patch_face_transformation</a>, possibly modified by <a class="el" href="forestclaw_8h.html#a635fbdf7339e70de56b6cd0704c2dc8c">fclaw_patch_face_transformation_block</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if valid, false if not. </dd></dl>

</div>
</div>
<a id="a8973008fb6434d4bb0581d6231955f83" name="a8973008fb6434d4bb0581d6231955f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8973008fb6434d4bb0581d6231955f83">&#9670;&#160;</a></span>fclaw_patch_get_ghost_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_get_ghost_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The the block number of a ghost patch. </p>
<p>This should only be called on a ghost patch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>the patch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int the block number. </dd></dl>

</div>
</div>
<a id="a7e81f3e98a53bfeb638faeae148f8aad" name="a7e81f3e98a53bfeb638faeae148f8aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e81f3e98a53bfeb638faeae148f8aad">&#9670;&#160;</a></span>fclaw_patch_is_first_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_is_first_sibling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a patch is the first in a family of four siblings. </p>
<p>For ghost patches, we always return false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A patch with properly set member variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if patch is the first sibling. </dd></dl>

</div>
</div>
<a id="a943da1eeb67c4d6802d8733dfe7cdda2" name="a943da1eeb67c4d6802d8733dfe7cdda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943da1eeb67c4d6802d8733dfe7cdda2">&#9670;&#160;</a></span>fclaw_patch_is_ghost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_is_ghost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="forestclaw_8h.html#ab11426617a538045942e453095717e18">fclaw_patch_t</a> *&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a patch is a parallel ghost patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A patch with properly set member variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if patch is off-processor, false if local. </dd></dl>

</div>
</div>
<a id="ac75941e1a4b68d123992b9dfc2ee853f" name="ac75941e1a4b68d123992b9dfc2ee853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75941e1a4b68d123992b9dfc2ee853f">&#9670;&#160;</a></span>fclaw_patch_mark_coarsen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_mark_coarsen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a patch for coarsening. </p>
<p>This must ONLY be called for local patches. Coarsening will only happen if the patch family is not further refined and all sibling patches are marked as well. It is safe to call this function from an iterator callback except <a class="el" href="forestclaw_8h.html#a2e6b97982a7b5cd22c753bd83036e40b">fclaw_domain_iterate_adapted</a>. </p>

</div>
</div>
<a id="a7c1d16846a632d2b0909ea64dc0356bd" name="a7c1d16846a632d2b0909ea64dc0356bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1d16846a632d2b0909ea64dc0356bd">&#9670;&#160;</a></span>fclaw_patch_mark_refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fclaw_patch_mark_refine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a patch for refinement. </p>
<p>This must ONLY be called for local patches. It is safe to call this function from an iterator callback except <a class="el" href="forestclaw_8h.html#a2e6b97982a7b5cd22c753bd83036e40b">fclaw_domain_iterate_adapted</a>. </p>

</div>
</div>
<a id="a3d644edc13af13fa05287c4091c6f02b" name="a3d644edc13af13fa05287c4091c6f02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d644edc13af13fa05287c4091c6f02b">&#9670;&#160;</a></span>fclaw_patch_normal_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclaw_patch_normal_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="forestclaw_8h.html#a345fbab290457176694917260185b95a">fclaw_domain_t</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the normal to a face neighbor align. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Valid domain structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockno</td><td>Number of the block within the domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patchno</td><td>Number of the patch within the block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceno</td><td>Number of the face of the patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if normals match, false for mismatch. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
